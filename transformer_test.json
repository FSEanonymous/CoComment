{"id": 0, "code": "static void XLog Wal Rcv Send Switch Request ( void ) { volatile Wal Rcv Data * walrcv = t thrd . walreceiverfuncs cxt . Wal Rcv ; char buf [ sizeof ( Standby Switch Request Message ) + 1 ] ; Timestamp Tz local now ; errno t errorno = EOK ; local now = Get Current Timestamp ( ) ; t thrd . walreceiver cxt . request message - > send Time = local now ; Spin Lock Acquire ( & walrcv - > mutex ) ; t thrd . walreceiver cxt . request message - > demote Mode = walrcv - > node state ; walrcv - > node state = NODESTATE STANDBY WAITING ; Spin Lock Release ( & walrcv - > mutex ) ; buf [ 0 ] = ' s ' ; errorno = memcpy s ( & buf [ 1 ] , sizeof ( Standby Switch Request Message ) , t thrd . walreceiver cxt . request message , sizeof ( Standby Switch Request Message ) ) ; securec check ( errorno , \" \\ 0 \" , \" \\ 0 \" ) ; libpqrcv send ( buf , sizeof ( Standby Switch Request Message ) + 1 ) ; Send Postmaster Signal ( PMSIGNAL UPDATE WAITING ) ; ereport ( LOG , ( errmsg ( \" send % s switchover request to primary \" , Demote Mode Desc ( t thrd . walreceiver cxt . request message - > demote Mode ) ) ) ) ; }", "predictions": ["this function is used to obtain"], "references": ["send a switch request message to the master server, indicating the current time."], "bleu": 0.06878769894132081, "rouge_l": 0.09870550161812298}
{"id": 1, "code": "Datum pg stat get wal senders ( PG FUNCTION ARGS ) { # define PG STAT GET WAL SENDERS COLS 21 Tuple Desc tupdesc ; Tuplestorestate * tupstore = NULL ; int * sync priority = NULL ; int i = 0 ; volatile Ha Shmem Data * hashmdata = t thrd . postmaster cxt . Ha Shm Data ; List * sync standbys = NIL ; tupstore = Build Tuple Result ( fcinfo , & tupdesc ) ; if ( IS DN DUMMY STANDYS MODE ( ) ) { sync priority = ( int * ) palloc ( sizeof ( int ) * g instance . attr . attr storage . max wal senders ) ; for ( i = 0 ; i < g instance . attr . attr storage . max wal senders ; i + + ) { volatile Wal Snd * walsnd = & t thrd . walsender cxt . Wal Snd Ctl - > walsnds [ i ] ; if ( walsnd - > pid ! = 0 ) { sync priority [ i ] = XLog Rec Ptr Is Invalid ( walsnd - > flush ) ? 0 : walsnd - > sync standby priority ; } } } LWLock Acquire ( Sync Rep Lock , LW SHARED ) ; sync standbys = Sync Rep Get Sync Standbys ( NULL ) ; LWLock Release ( Sync Rep Lock ) ; for ( i = 0 ; i < g instance . attr . attr storage . max wal senders ; i + + ) { volatile Wal Snd * walsnd = & t thrd . walsender cxt . Wal Snd Ctl - > walsnds [ i ] ; char location [ MAXFNAMELEN ] = { 0 } ; XLog Rec Ptr sent Rec Ptr ; XLog Rec Ptr local write ; XLog Rec Ptr flush ; XLog Rec Ptr apply ; Wal Snd State state ; XLog Rec Ptr snd Write ; XLog Rec Ptr snd Flush ; XLog Rec Ptr snd Replay ; XLog Rec Ptr Rcv Received ; XLog Rec Ptr sync Start ; int sync percent = 0 ; Server Mode peer role ; Snd Role snd role ; Db State peer state ; Server Mode local role ; char localip [ IP LEN ] = { 0 } ; char remoteip [ IP LEN ] = { 0 } ; Timestamp Tz catchup time [ 2 ] ; int localport = 0 ; int remoteport = 0 ; Datum values [ PG STAT GET WAL SENDERS COLS ] ; bool nulls [ PG STAT GET WAL SENDERS COLS ] ; int j = 0 ; errno t rc = 0 ; int ret = 0 ; int priority = 0 ; Spin Lock Acquire ( & hashmdata - > mutex ) ; local role = hashmdata - > current mode ; if ( walsnd - > pid = = 0 ) { Spin Lock Release ( & hashmdata - > mutex ) ; continue ; } Spin Lock Release ( & hashmdata - > mutex ) ; Spin Lock Acquire ( & walsnd - > mutex ) ; localport = walsnd - > wal sender channel . localport ; remoteport = walsnd - > wal sender channel . remoteport ; rc = strncpy s ( localip , IP LEN , ( char * ) walsnd - > wal sender channel . localhost , IP LEN - 1 ) ; securec check ( rc , \" \\ 0 \" , \" \\ 0 \" ) ; rc = strncpy s ( remoteip , IP LEN , ( char * ) walsnd - > wal sender channel . remotehost , IP LEN - 1 ) ; securec check ( rc , \" \\ 0 \" , \" \\ 0 \" ) ; localip [ IP LEN - 1 ] = ' \\ 0 ' ; remoteip [ IP LEN - 1 ] = ' \\ 0 ' ; peer role = walsnd - > peer role ; snd role = walsnd - > send Role ; peer state = walsnd - > peer state ; state = walsnd - > state ; sent Rec Ptr = walsnd - > sent Ptr ; local write = walsnd - > write ; flush = walsnd - > flush ; apply = walsnd - > apply ; Rcv Received = walsnd - > receive ; sync Start = walsnd - > sync Percent Count Start ; catchup time [ 0 ] = walsnd - > catchup Time [ 0 ] ; catchup time [ 1 ] = walsnd - > catchup Time [ 1 ] ; if ( IS DN MULTI STANDYS MODE ( ) ) priority = walsnd - > sync standby priority ; Spin Lock Release ( & walsnd - > mutex ) ; if ( local role = = PRIMARY MODE ) { snd Write = GetXLog Write Rec Ptr ( ) ; snd Flush = Get Flush Rec Ptr ( ) ; snd Replay = snd Flush ; } else { snd Write = Get Wal Rcv Write Rec Ptr ( NULL ) ; snd Flush = Get Standby Flush Rec Ptr ( NULL ) ; snd Replay = GetXLog Replay Rec Ptr ( NULL ) ; } rc = memset s ( nulls , sizeof ( nulls ) , 0 , sizeof ( nulls ) ) ; securec check ( rc , \" \\ 0 \" , \" \\ 0 \" ) ; values [ j + + ] = Int64 Get Datum ( walsnd - > pid ) ; values [ j + + ] = Int32 Get Datum ( walsnd - > lwp Id ) ; if ( ! superuser ( ) ) { rc = memset s ( & nulls [ j ] , PG STAT GET WAL SENDERS COLS - j , true , PG STAT GET WAL SENDERS COLS - j ) ; securec check ( rc , \" \\ 0 \" , \" \\ 0 \" ) ; } else { values [ j + + ] = CString Get Text Datum ( wal get role string ( local role ) ) ; if ( snd role = = SNDROLE PRIMARY DUMMYSTANDBY ) values [ j + + ] = CString Get Text Datum ( \" Secondary \" ) ; else values [ j + + ] = CString Get Text Datum ( wal get role string ( peer role ) ) ; values [ j + + ] = CString Get Text Datum ( wal get db state string ( peer state ) ) ; values [ j + + ] = CString Get Text Datum ( Wal Snd Get State String ( state ) ) ; if ( catchup time [ 0 ] ! = 0 ) values [ j + + ] = Timestamp Tz Get Datum ( catchup time [ 0 ] ) ; else nulls [ j + + ] = true ; if ( catchup time [ 1 ] ! = 0 & & ( state ! = WALSNDSTATE CATCHUP ) ) values [ j + + ] = Timestamp Tz Get Datum ( catchup time [ 1 ] ) ; else nulls [ j + + ] = true ; ret = snprintf s ( location , sizeof ( location ) , sizeof ( location ) - 1 , \" % X / % X \" , ( uint32 ) ( sent Rec Ptr > > 32 ) , ( uint32 ) sent Rec Ptr ) ; securec check ss ( ret , \" \\ 0 \" , \" \\ 0 \" ) ; values [ j + + ] = CString Get Text Datum ( location ) ; if ( snd Write = = 0 ) SETXLOGLOCATION ( snd Write , sent Rec Ptr ) ret = snprintf s ( location , sizeof ( location ) , sizeof ( location ) - 1 , \" % X / % X \" , ( uint32 ) ( snd Write > > 32 ) , ( uint32 ) snd Write ) ; securec check ss ( ret , \" \\ 0 \" , \" \\ 0 \" ) ; values [ j + + ] = CString Get Text Datum ( location ) ; if ( snd Flush = = 0 ) SETXLOGLOCATION ( snd Flush , sent Rec Ptr ) ret = snprintf s ( location , sizeof ( location ) , sizeof ( location ) - 1 , \" % X / % X \" , ( uint32 ) ( snd Flush > > 32 ) , ( uint32 ) snd Flush ) ; securec check ss ( ret , \" \\ 0 \" , \" \\ 0 \" ) ; values [ j + + ] = CString Get Text Datum ( location ) ; if ( snd Replay = = 0 ) SETXLOGLOCATION ( snd Replay , sent Rec Ptr ) ret = snprintf s ( location , sizeof ( location ) , sizeof ( location ) - 1 , \" % X / % X \" , ( uint32 ) ( snd Replay > > 32 ) , ( uint32 ) snd Replay ) ; securec check ss ( ret , \" \\ 0 \" , \" \\ 0 \" ) ; values [ j + + ] = CString Get Text Datum ( location ) ; if ( Rcv Received = = 0 ) SETXLOGLOCATION ( Rcv Received , sent Rec Ptr ) ret = snprintf s ( location , sizeof ( location ) , sizeof ( location ) - 1 , \" % X / % X \" , ( uint32 ) ( Rcv Received > > 32 ) , ( uint32 ) Rcv Received ) ; securec check ss ( ret , \" \\ 0 \" , \" \\ 0 \" ) ; values [ j + + ] = CString Get Text Datum ( location ) ; if ( local write = = 0 ) SETXLOGLOCATION ( local write , sent Rec Ptr ) ret = snprintf s ( location , sizeof ( location ) , sizeof ( location ) - 1 , \" % X / % X \" , ( uint32 ) ( local write > > 32 ) , ( uint32 ) local write ) ; securec check ss ( ret , \" \\ 0 \" , \" \\ 0 \" ) ; values [ j + + ] = CString Get Text Datum ( location ) ; if ( flush = = 0 ) SETXLOGLOCATION ( flush , sent Rec Ptr ) ret = snprintf s ( location , sizeof ( location ) , sizeof ( location ) - 1 , \" % X / % X \" , ( uint32 ) ( flush > > 32 ) , ( uint32 ) flush ) ; securec check ss ( ret , \" \\ 0 \" , \" \\ 0 \" ) ; values [ j + + ] = CString Get Text Datum ( location ) ; if ( apply = = 0 ) SETXLOGLOCATION ( apply , sent Rec Ptr ) ret = snprintf s ( location , sizeof ( location ) , sizeof ( location ) - 1 , \" % X / % X \" , ( uint32 ) ( apply > > 32 ) , ( uint32 ) apply ) ; securec check ss ( ret , \" \\ 0 \" , \" \\ 0 \" ) ; values [ j + + ] = CString Get Text Datum ( location ) ; sync percent = Get Sync Percent ( sync Start , snd Flush , flush ) ; ret = snprintf s ( location , sizeof ( location ) , sizeof ( location ) - 1 , \" % d % % \" , sync percent ) ; securec check ss ( ret , \" \\ 0 \" , \" \\ 0 \" ) ; values [ j + + ] = CString Get Text Datum ( location ) ; if ( IS DN DUMMY STANDYS MODE ( ) ) { if ( ! Sync Rep Requested ( ) ) { values [ j + + ] = CString Get Text Datum ( \" Async \" ) ; values [ j + + ] = Int32 Get Datum ( 0 ) ; } else { values [ j + + ] = CString Get Text Datum ( \" Sync \" ) ; values [ j + + ] = Int32 Get Datum ( sync priority [ i ] ) ; } } else { priority = XLog Rec Ptr Is Invalid ( walsnd - > flush ) ? 0 : priority ; if ( priority = = 0 ) values [ j + + ] = CString Get Text Datum ( \" Async \" ) ; else if ( list member int ( sync standbys , i ) ) { values [ j + + ] = t thrd . syncrep cxt . Sync Rep Config - > syncrep method = = SYNC REP PRIORITY ? CString Get Text Datum ( \" Sync \" ) : CString Get Text Datum ( \" Quorum \" ) ; } else values [ j + + ] = CString Get Text Datum ( \" Potential \" ) ; values [ j + + ] = Int32 Get Datum ( priority ) ; } if ( most available sync ) values [ j + + ] = CString Get Text Datum ( \" On \" ) ; else values [ j + + ] = CString Get Text Datum ( \" Off \" ) ; ret = snprintf s ( location , sizeof ( location ) , sizeof ( location ) - 1 , \" % s : % d - - > % s : % d \" , localip , localport , remoteip , remoteport ) ; securec check ss ( ret , \" \\ 0 \" , \" \\ 0 \" ) ; values [ j + + ] = CString Get Text Datum ( location ) ; } tuplestore putvalues ( tupstore , tupdesc , values , nulls ) ; } list free ( sync standbys ) ; if ( sync priority ! = NULL ) { pfree ( sync priority ) ; sync priority = NULL ; } tuplestore donestoring ( tupstore ) ; return ( Datum ) 0 ; }", "predictions": ["this function is used to obtain"], "references": ["return to wal sender activity"], "bleu": 0.22089591134157885, "rouge_l": 0.18484848484848485}
{"id": 2, "code": "static void Data Writer Hash Create ( void ) { if ( t thrd . datarcvwriter cxt . data writer rel tab = = NULL ) { HASHCTL ctl ; errno t rc = 0 ; rc = memset s ( & ctl , sizeof ( ctl ) , 0 , sizeof ( ctl ) ) ; securec check ( rc , \" \" , \" \" ) ; ctl . keysize = sizeof ( data writer rel key ) ; ctl . entrysize = sizeof ( data writer rel ) ; ctl . hash = tag hash ; t thrd . datarcvwriter cxt . data writer rel tab = hash create ( \" data writer rel table \" , 100 , & ctl , HASH ELEM | HASH FUNCTION ) ; } else return ; }", "predictions": ["this function is used to get"], "references": ["realize the function of creating hash table for data input"], "bleu": 0.11341174240707227, "rouge_l": 0.11960784313725491}
{"id": 3, "code": "bool Heartbeat Server : : Restart ( ) { Stop ( ) ; return Start ( ) ; }", "predictions": ["get the"], "references": ["the purpose of this function is to close before opening."], "bleu": 0.013916876033168307, "rouge_l": 0.14878048780487804}
{"id": 4, "code": "static void Data Rcv Writer Quick Die ( SIGNAL ARGS ) { gs signal setmask ( & t thrd . libpq cxt . Block Sig , NULL ) ; on exit reset ( ) ; gs thread exit ( 2 ) ; }", "predictions": ["function function: < br / void"], "references": ["fast completion of data writing"], "bleu": 0.18575057999133598, "rouge_l": 0.0}
{"id": 5, "code": "bool Resolve Cmin Cmax During Decoding ( HTAB * tuplecid data , Snapshot snapshot , Heap Tuple htup , Buffer buffer , Command Id * cmin , Command Id * cmax ) { Reorder Buffer Tuple Cid Key key ; Reorder Buffer Tuple Cid Ent * ent = NULL ; Fork Number forkno = Invalid Fork Number ; Block Number blockno = Invalid Block Number ; bool updated mapping = false ; int rc = 0 ; rc = memset s ( & key , sizeof ( key ) , 0 , sizeof ( key ) ) ; securec check ( rc , \" \" , \" \" ) ; Assert ( ! Buffer Is Local ( buffer ) ) ; Buffer Get Tag ( buffer , & key . relnode , & forkno , & blockno ) ; Assert ( forkno = = MAIN FORKNUM ) ; Assert ( blockno = = Item Pointer Get Block Number ( & htup - > t self ) ) ; Item Pointer Copy ( & htup - > t self , & key . tid ) ; restart : ent = ( Reorder Buffer Tuple Cid Ent * ) hash search ( tuplecid data , ( void * ) & key , HASH FIND , NULL ) ; if ( ent = = NULL & & ! updated mapping ) { Update Logical Mappings ( tuplecid data , htup - > t table Oid , snapshot ) ; updated mapping = true ; goto restart ; } else if ( ent = = NULL ) return false ; if ( cmin ! = NULL ) * cmin = ent - > cmin ; if ( cmax ! = NULL ) * cmax = ent - > cmax ; return true ; }", "predictions": ["function function:"], "references": ["the cmin / cmax of the tuple is found during logical decoding independent of the combination key."], "bleu": 0.0003533894443723512, "rouge_l": 0.0}
{"id": 6, "code": "static void Data Rcv Quick Die Handler ( SIGNAL ARGS ) { gs signal setmask ( & t thrd . libpq cxt . Block Sig , NULL ) ; on exit reset ( ) ; exit ( 2 ) ; }", "predictions": ["function function: < br / void"], "references": ["this function is used to quickly stop datarcv after the sigquit parameter in the previous function takes effect"], "bleu": 0.02989501072722226, "rouge_l": 0.07644110275689221}
{"id": 7, "code": "bool Data Rcv In Progress ( void ) { volatile Data Rcv Data * datarcv = t thrd . datareceiver cxt . Data Rcv ; Data Rcv State state ; pg time t start Time ; Spin Lock Acquire ( & datarcv - > mutex ) ; state = datarcv - > data Rcv State ; start Time = datarcv - > start Time ; Spin Lock Release ( & datarcv - > mutex ) ; if ( state = = DATARCV STARTING ) { pg time t now = ( pg time t ) time ( NULL ) ; if ( ( now - start Time ) > DATARCV STARTUP TIMEOUT ) { Spin Lock Acquire ( & datarcv - > mutex ) ; if ( datarcv - > data Rcv State = = DATARCV STARTING ) state = datarcv - > data Rcv State = DATARCV STOPPED ; Spin Lock Release ( & datarcv - > mutex ) ; ereport ( WARNING , ( errmsg ( \" shut down datareceiver due to start up timeout . \" ) ) ) ; } } if ( state ! = DATARCV STOPPED ) return true ; else return false ; }", "predictions": ["this function is used to obtain"], "references": ["this function is used to determine whether the datarcv is already in the process or is being started"], "bleu": 0.10950068597900019, "rouge_l": 0.3822055137844611}
{"id": 8, "code": "bool Heartbeat Server : : Add Connection ( Heartbeat Connection * con , Heartbeat Connection * * released Conn Ptr ) { * released Conn Ptr = NULL ; for ( int i = START REPLNODE NUM ; i < MAX REPLNODE NUM ; i + + ) { Repl Conn Info * replconninfo = t thrd . postmaster cxt . Repl Conn Array [ i ] ; if ( replconninfo = = NULL ) { continue ; } if ( strncmp ( ( char * ) replconninfo - > remotehost , con - > remote Host , IP LEN ) = = 0 & & replconninfo - > remoteheartbeatport = = con - > channel Identifier ) { if ( identified Conns [ i ] ! = NULL ) { ereport ( COMMERROR , ( errmsg ( \" The connection has existed and remove the old connection , \" \" remote ip : % s , remote heartbeat port : % d , old fd : % d , new fd : % d . \" , con - > remote Host , con - > channel Identifier , identified Conns [ i ] - > fd , con - > fd ) ) ) ; Remove Conn ( identified Conns [ i ] ) ; * released Conn Ptr = identified Conns [ i ] ; } identified Conns [ i ] = con ; ereport ( LOG , ( errmsg ( \" Adding connection successed , remote ip : % s , remote heartbeat port : % d . \" , con - > remote Host , con - > channel Identifier ) ) ) ; Remove Unidentified Connection ( con ) ; return true ; } } ereport ( COMMERROR , ( errmsg ( \" The connection is illegal , remote ip : % s , remote heartbeat port : % d . \" , con - > remote Host , con - > channel Identifier ) ) ) ; Remove Unidentified Connection ( con ) ; return false ; }", "predictions": ["function function:"], "references": ["this boolean type function is used to increase the parameterized connection to the heartbeat service"], "bleu": 0.0011423667500315906, "rouge_l": 0.10338983050847457}
{"id": 9, "code": "bool Wal Snd All In Progress ( int type ) { int i ; int num = 0 ; int all num = t thrd . syncrep cxt . Sync Rep Config - > nmembers ; for ( i = 0 ; i < g instance . attr . attr storage . max wal senders ; i + + ) { volatile Wal Snd * walsnd = & t thrd . walsender cxt . Wal Snd Ctl - > walsnds [ i ] ; Spin Lock Acquire ( & walsnd - > mutex ) ; if ( walsnd - > pid ! = 0 & & walsnd - > pid ! = t thrd . proc cxt . My Proc Pid & & ( ( walsnd - > send Role & type ) = = walsnd - > send Role ) ) { num + + ; } Spin Lock Release ( & walsnd - > mutex ) ; } if ( num > = all num ) { return true ; } else { return false ; } }", "predictions": ["this method"], "references": ["determine whether all the wal transmitters are in type"], "bleu": 0.019294409903971108, "rouge_l": 0.0}
{"id": 10, "code": "static void Shutdown Wal Rcv Writer ( int code , Datum arg ) { empty Wal Rcv Writer Latch ( ) ; }", "predictions": ["function function: Writer"], "references": ["close the wallcvwriter and clear the wallcvwriteratch to avoid occupying resources."], "bleu": 0.031392692871325185, "rouge_l": 0.0}
{"id": 11, "code": "void Send Base Backup ( Base Backup Cmd * cmd ) { DIR * dir = NULL ; Memory Context backup context ; Memory Context old context ; basebackup options opt ; parse basebackup options ( cmd - > options , & opt ) ; backup context = Alloc Set Context Create ( Current Memory Context , \" Streaming base backup context \" , ALLOCSET DEFAULT MINSIZE , ALLOCSET DEFAULT INITSIZE , ALLOCSET DEFAULT MAXSIZE ) ; old context = Memory Context Switch To ( backup context ) ; Wal Snd Set State ( WALSNDSTATE BACKUP ) ; if ( u sess - > attr . attr common . update process title ) { char activitymsg [ 50 ] ; int rc = 0 ; rc = snprintf s ( activitymsg , sizeof ( activitymsg ) , sizeof ( activitymsg ) - 1 , \" sending backup \\ \" % s \\ \" \" , opt . label ) ; securec check ss ( rc , \" \" , \" \" ) ; set ps display ( activitymsg , false ) ; } dir = Allocate Dir ( \" pg tblspc \" ) ; if ( dir = = NULL ) { ereport ( ERROR , ( errcode for file access ( ) , errmsg ( \" could not open directory \\ \" % s \\ \" : % m \" , \" pg tblspc \" ) ) ) ; return ; } send xlog location ( ) ; perform base backup ( & opt , dir ) ; Free Dir ( dir ) ; Memory Context Switch To ( old context ) ; Memory Context Delete ( backup context ) ; }", "predictions": ["this function is used to get the file"], "references": ["//called by the handlewalreplicationcommand function in walsender, the system enters the backup state"], "bleu": 0.09499501502705178, "rouge_l": 0.18263473053892215}
{"id": 12, "code": "static bool Sync Rep Cancel Wait ( void ) { bool success = false ; LWLock Acquire ( Sync Rep Lock , LW EXCLUSIVE ) ; if ( ! t thrd . proc - > sync Rep In Complete Queue ) { if ( ! SHMQueue Is Detached ( & ( t thrd . proc - > sync Rep Links ) ) ) SHMQueue Delete ( & ( t thrd . proc - > sync Rep Links ) ) ; t thrd . proc - > sync Rep State = SYNC REP NOT WAITING ; success = true ; } LWLock Release ( Sync Rep Lock ) ; return success ; }", "predictions": ["this static"], "references": ["gets the synceplock and cancels all waiting that is not currently completed in the queue."], "bleu": 0.0009606121050066008, "rouge_l": 0.0}
{"id": 13, "code": "static void Sync Rep Get Oldest Sync Rec Ptr ( XLog Rec Ptr * receive Ptr , XLog Rec Ptr * write Ptr , XLog Rec Ptr * flush Ptr , XLog Rec Ptr * replay Ptr , List * sync standbys ) { List Cell * cell = NULL ; foreach ( cell , sync standbys ) { Wal Snd * walsnd = & t thrd . walsender cxt . Wal Snd Ctl - > walsnds [ lfirst int ( cell ) ] ; XLog Rec Ptr receive ; XLog Rec Ptr write ; XLog Rec Ptr flush ; XLog Rec Ptr apply ; Spin Lock Acquire ( & walsnd - > mutex ) ; receive = walsnd - > receive ; write = walsnd - > write ; flush = walsnd - > flush ; apply = walsnd - > apply ; Spin Lock Release ( & walsnd - > mutex ) ; if ( XLog Rec Ptr Is Invalid ( * write Ptr ) | | ! XLByteLE ( * write Ptr , write ) ) * write Ptr = write ; if ( XLog Rec Ptr Is Invalid ( * flush Ptr ) | | ! XLByteLE ( * flush Ptr , flush ) ) * flush Ptr = flush ; if ( XLog Rec Ptr Is Invalid ( * receive Ptr ) | | ! XLByteLE ( * receive Ptr , receive ) ) * receive Ptr = receive ; if ( XLog Rec Ptr Is Invalid ( * replay Ptr ) | | ! XLByteLE ( * replay Ptr , apply ) ) * replay Ptr = apply ; } }", "predictions": ["this function is used to write"], "references": ["calculate the earliest write, refresh and application location in synchronous standby."], "bleu": 0.08072686929338534, "rouge_l": 0.0}
{"id": 14, "code": "static void Process EndXLog Message ( EndXLog Message * endXLog Message ) { ereport ( dummy Standby Mode ? DEBUG2 : LOG , ( errmsg ( \" sync Secondary Standby xlog done \" ) ) ) ; if ( endXLog Message - > percent = = SYNC DUMMY STANDBY END ) { Set Wal Rcv Dummy Standby Sync Percent ( SYNC DUMMY STANDBY END ) ; if ( dummy Standby Mode ) Sync System Identifier ( ) ; } }", "predictions": ["function function: get"], "references": ["process the rmxlogmessage received from the primary sender with the message type of \"e\"."], "bleu": 0.01154872631036983, "rouge_l": 0.0}
{"id": 15, "code": "static void Wal Snd Refresh Percent Count Start Lsn ( XLog Rec Ptr current Max Lsn , XLog Rec Ptr current Done Lsn ) { uint64 cound Window = ( ( uint64 ) Wal Get Sync Count Window ( ) * XLOG SEG SIZE ) ; volatile Wal Snd * walsnd = t thrd . walsender cxt . My Wal Snd ; XLog Rec Ptr base Start Lsn = InvalidXLog Rec Ptr ; if ( ! walsnd ) { return ; } if ( walsnd - > state = = WALSNDSTATE CATCHUP ) { return ; } if ( XLog Diff ( current Max Lsn , current Done Lsn ) < cound Window ) { Wal Snd Set Percent Count Start Lsn ( InvalidXLog Rec Ptr ) ; } else { Spin Lock Acquire ( & walsnd - > mutex ) ; base Start Lsn = walsnd - > sync Percent Count Start ; Spin Lock Release ( & walsnd - > mutex ) ; if ( ! XLByteEQ ( base Start Lsn , InvalidXLog Rec Ptr ) ) { return ; } Wal Snd Set Percent Count Start Lsn ( current Done Lsn ) ; } }", "predictions": ["this method"], "references": ["set to start sending not for the current walsender"], "bleu": 0.019294409903971108, "rouge_l": 0.0}
{"id": 16, "code": "static void destroy client and server ( ) { if ( g heartbeat server ! = NULL ) { delete g heartbeat server ; g heartbeat server = NULL ; } if ( g heartbeat client ! = NULL ) { delete g heartbeat client ; g heartbeat client = NULL ; } }", "predictions": ["lines lines implement implement"], "references": ["clear client and server cache < br / >"], "bleu": 0.08656385444580769, "rouge_l": 0.0}
{"id": 17, "code": "void Sync Rep Wait ForLSN ( XLog Rec Ptr Xact CommitLSN ) { char * new status = NULL ; const char * old status = NULL ; int mode = Sync Rep Wait Mode ; if ( ! u sess - > attr . attr storage . enable stream replication | | ! Sync Rep Requested ( ) | | ! Sync Standbys Defined ( ) | | ( t thrd . postmaster cxt . Ha Shm Data - > current mode = = NORMAL MODE ) ) return ; Assert ( SHMQueue Is Detached ( & ( t thrd . proc - > sync Rep Links ) ) ) ; Assert ( t thrd . walsender cxt . Wal Snd Ctl ! = NULL ) ; HOLD INTERRUPTS ( ) ; ( void ) LWLock Acquire ( Sync Rep Lock , LW EXCLUSIVE ) ; Assert ( t thrd . proc - > sync Rep State = = SYNC REP NOT WAITING ) ; if ( ! t thrd . walsender cxt . Wal Snd Ctl - > sync standbys defined | | XLByteLE ( Xact CommitLSN , t thrd . walsender cxt . Wal Snd Ctl - > lsn [ mode ] ) | | t thrd . walsender cxt . Wal Snd Ctl - > sync master standalone ) { LWLock Release ( Sync Rep Lock ) ; RESUME INTERRUPTS ( ) ; return ; } t thrd . proc - > waitLSN = Xact CommitLSN ; t thrd . proc - > sync Rep State = SYNC REP WAITING ; Sync Rep Queue Insert ( mode ) ; Assert ( Sync Rep Queue Is Ordered ByLSN ( mode ) ) ; LWLock Release ( Sync Rep Lock ) ; if ( u sess - > attr . attr common . update process title ) { int len ; errno t ret = EOK ; int rc = 0 ; old status = get ps display ( & len ) ; new status = ( char * ) palloc ( len + 32 + 1 ) ; ret = memcpy s ( new status , len , old status , len ) ; securec check ( ret , \" \" , \" \" ) ; # define NEW STATUS LEN 33 rc = snprintf s ( new status + len , NEW STATUS LEN , NEW STATUS LEN - 1 , \" waiting for % X / % X \" , ( uint32 ) ( Xact CommitLSN > > 32 ) , ( uint32 ) Xact CommitLSN ) ; securec check ss ( rc , \" \" , \" \" ) ; set ps display ( new status , false ) ; new status [ len ] = ' \\ 0 ' ; } Wait State old Status = pgstat report waitstatus ( STATE WAIT WALSYNC ) ; for ( ; ; ) { Reset Latch ( & t thrd . proc - > proc Latch ) ; # ifdef ENABLE DISTRIBUTE TEST if ( TEST STUB ( DN STANDBY SLEEPIN SYNCCOMMIT , stub sleep emit ) ) { ereport ( get distribute test param ( ) - > elevel , ( errmsg ( \" sleep emit happen during Sync Rep Wait ForLSN time : % ds , stub name : % s \" , get distribute test param ( ) - > sleep time , get distribute test param ( ) - > test stub name ) ) ) ; } # endif if ( t thrd . proc - > sync Rep State = = SYNC REP WAIT COMPLETE ) break ; if ( t thrd . int cxt . Proc Die Pending | | t thrd . proc cxt . proc exit inprogress ) { ereport ( WARNING , ( errcode ( ERRCODE ADMIN SHUTDOWN ) , errmsg ( \" canceling the wait for synchronous replication and terminating connection due to \" \" administrator command \" ) , errdetail ( \" The transaction has already committed locally , but might not have been replicated to \" \" the standby . \" ) ) ) ; t thrd . postgres cxt . where To Send Output = Dest None ; if ( Sync Rep Cancel Wait ( ) ) { break ; } } if ( t thrd . int cxt . Query Cancel Pending ) { if ( ! t thrd . vacuum cxt . in vacuum ) { t thrd . int cxt . Query Cancel Pending = false ; } ereport ( WARNING , ( errmsg ( \" canceling wait for synchronous replication due to user request \" ) , errdetail ( \" The transaction has already committed locally , but might not have been replicated to \" \" the standby . \" ) ) ) ; if ( Sync Rep Cancel Wait ( ) ) { break ; } } if ( ! Postmaster Is Alive ( ) ) { t thrd . int cxt . Proc Die Pending = true ; t thrd . postgres cxt . where To Send Output = Dest None ; if ( Sync Rep Cancel Wait ( ) ) { break ; } } if ( t thrd . walsender cxt . Wal Snd Ctl - > sync master standalone | | synchronous commit < = SYNCHRONOUS COMMIT LOCAL FLUSH ) { ereport ( WARNING , ( errmsg ( \" canceling wait for synchronous replication due to syncmaster standalone . \" ) , errdetail ( \" The transaction has already committed locally , but might not have been replicated to \" \" the standby . \" ) ) ) ; if ( Sync Rep Cancel Wait ( ) ) { break ; } } Wait Latch ( & t thrd . proc - > proc Latch , WL LATCH SET | WL TIMEOUT | WL POSTMASTER DEATH , 3000 L ) ; } pg read barrier ( ) ; if ( t thrd . proc - > sync Rep Links . next ) { Sync Rep Notify Complete ( ) ; } ( void ) pgstat report waitstatus ( old Status ) ; Assert ( SHMQueue Is Detached ( & ( t thrd . proc - > sync Rep Links ) ) ) ; t thrd . proc - > sync Rep State = SYNC REP NOT WAITING ; t thrd . proc - > sync Rep In Complete Queue = false ; t thrd . proc - > waitLSN = 0 ; if ( new status ! = NULL ) { set ps display ( new status , false ) ; pfree ( new status ) ; new status = NULL ; } RESUME INTERRUPTS ( ) ; }", "predictions": ["function function:"], "references": ["if using requests, wait for synchronous replication."], "bleu": 0.0524476438328049, "rouge_l": 0.0}
{"id": 18, "code": "static int server loop ( void ) { Timestamp Tz last send time = 0 ; sigset t block sig set ; struct epoll event events [ MAX EVENTS ] ; set block sigmask ( & block sig set ) ; int epollfd = epoll create ( MAX EVENTS ) ; if ( epollfd < 0 ) { ereport ( ERROR , ( errmsg ( \" create epoll failed % d . \" , epollfd ) ) ) ; return 1 ; } if ( create client and server ( epollfd ) ) { goto OUT ; } for ( ; ; ) { if ( deal with sigup ( ) ) { break ; } if ( t thrd . heartbeat cxt . shutdown requested ) { u sess - > attr . attr common . Exit On Any Error = true ; g instance . heartbeat cxt . heartbeat running = false ; destroy client and server ( ) ; ( void ) close ( epollfd ) ; proc exit ( 0 ) ; } ereport ( DEBUG2 , ( errmsg ( \" heartbeat . . . \" ) ) ) ; if ( g heartbeat client & & ! g heartbeat client - > Is Connect ( ) & & g heartbeat client - > Connect ( ) ) { last send time = Get Current Timestamp ( ) ; } if ( deal with events ( epollfd , events , & block sig set ) ) { break ; } if ( g heartbeat client ) { delay control ( last send time ) ; if ( g heartbeat client - > Is Connect ( ) & & g heartbeat client - > Send Beat Heart Packet ( ) ) { last send time = Get Current Timestamp ( ) ; } } } OUT : g instance . heartbeat cxt . heartbeat running = false ; destroy client and server ( ) ; ( void ) close ( epollfd ) ; return 1 ; }", "predictions": ["create a a"], "references": ["traverses the search and returns an integer return value"], "bleu": 0.06114461654585454, "rouge_l": 0.0}
{"id": 19, "code": "String Info get rcv slot name ( void ) { String Info slotname = make String Info ( ) ; volatile Wal Rcv Data * walrcv = t thrd . walreceiverfuncs cxt . Wal Rcv ; if ( IS DN DUMMY STANDYS MODE ( ) ) { Spin Lock Acquire ( & walrcv - > mutex ) ; append String Info ( slotname , \" % s \" , g instance . attr . attr common . PGXCNode Name ) ; Spin Lock Release ( & walrcv - > mutex ) ; } return slotname ; }", "predictions": ["this function is used to obtain"], "references": ["get the slot name. to create a slot in virtual standby mode, return the slot name."], "bleu": 0.041721848418993325, "rouge_l": 0.0840220385674931}
{"id": 20, "code": "static void Wal Snd Handshake ( void ) { String Info Data input message ; bool replication started = false ; int sleeptime = 0 ; int timeout = 0 ; const int TIMEOUT TIMES = 4 ; volatile Wal Snd * walsnd = t thrd . walsender cxt . My Wal Snd ; init String Info ( & input message ) ; if ( walsnd - > send Role = = SNDROLE PRIMARY BUILDSTANDBY ) timeout = TIMEOUT TIMES * u sess - > attr . attr storage . wal sender timeout ; else timeout = u sess - > attr . attr storage . wal sender timeout ; while ( ! replication started ) { int firstchar ; Wal Snd Set State ( WALSNDSTATE STARTUP ) ; set ps display ( \" idle \" , false ) ; if ( t thrd . walsender cxt . walsender ready to stop | | t thrd . walsender cxt . walsender shutdown requested ) { ereport ( LOG , ( errmsg ( \" caught ready to stop or shutdown request \" ) ) ) ; proc exit ( 0 ) ; } if ( ! pq select ( NAPTIME PER CYCLE ) ) { sleeptime + = NAPTIME PER CYCLE ; if ( timeout > 0 & & sleeptime > = timeout ) { ereport ( COMMERROR , ( errcode ( ERRCODE PROTOCOL VIOLATION ) , errmsg ( \" No message received from standby for maximum time \" ) ) ) ; proc exit ( 0 ) ; } continue ; } sleeptime = 0 ; firstchar = pq getbyte ( ) ; if ( ! Postmaster Is Alive ( ) ) gs thread exit ( 1 ) ; if ( t thrd . walsender cxt . got SIGHUP ) { t thrd . walsender cxt . got SIGHUP = false ; Process Config File ( PGC SIGHUP ) ; } if ( firstchar ! = EOF ) { if ( pq getmessage ( & input message , 0 ) ) firstchar = EOF ; } switch ( firstchar ) { case ' Q ' : { const char * query string = NULL ; query string = pq getmsgstring ( & input message ) ; pq getmsgend ( & input message ) ; if ( Handle Wal Replication Command ( query string ) ) { replication started = true ; } } break ; case ' X ' : case ' c ' : proc exit ( 0 ) ; case ' P ' : break ; case EOF : ereport ( COMMERROR , ( errcode ( ERRCODE PROTOCOL VIOLATION ) , errmsg ( \" unexpected EOF on standby connection \" ) ) ) ; proc exit ( 0 ) ; default : ereport ( FATAL , ( errcode ( ERRCODE PROTOCOL VIOLATION ) , errmsg ( \" invalid standby handshake message type % d \" , firstchar ) ) ) ; } } }", "predictions": ["function function: < br / >"], "references": ["this function is used to execute the received command"], "bleu": 0.1339801428338312, "rouge_l": 0.12869198312236285}
{"id": 21, "code": "static void change cb wrapper ( Reorder Buffer * cache , Reorder BufferTXN * txn , Relation relation , Reorder Buffer Change * change ) { Logical Decoding Context * ctx = ( Logical Decoding Context * ) cache - > private data ; Logical Error Callback State state ; Error Context Callback errcallback ; Assert ( ! ctx - > fast forward ) ; state . ctx = ctx ; state . callback name = \" change \" ; state . report location = change - > lsn ; errcallback . callback = output plugin error callback ; errcallback . arg = ( void * ) & state ; errcallback . previous = t thrd . log cxt . error context stack ; t thrd . log cxt . error context stack = & errcallback ; ctx - > accept writes = true ; ctx - > write xid = txn - > xid ; ctx - > write location = change - > lsn ; ctx - > callbacks . change cb ( ctx , txn , relation , change ) ; t thrd . log cxt . error context stack = errcallback . previous ; }", "predictions": ["this function is used to be"], "references": ["submit from modification point in encapsulated compilation environment"], "bleu": 0.13309610652103346, "rouge_l": 0.0}
{"id": 22, "code": "static void Wal Snd Set Percent Count Start Lsn ( XLog Rec Ptr start Lsn ) { volatile Wal Snd * walsnd = t thrd . walsender cxt . My Wal Snd ; Spin Lock Acquire ( & walsnd - > mutex ) ; walsnd - > sync Percent Count Start = start Lsn ; Spin Lock Release ( & walsnd - > mutex ) ; }", "predictions": ["this static"], "references": ["send lsn information to the latest walsender process."], "bleu": 0.031811104014284386, "rouge_l": 0.0}
{"id": 23, "code": "static void Wal Snd Write Logical AdvanceXLog ( Timestamp Tz now ) { Timestamp Tz timegap ; if ( t thrd . walsender cxt . last logical xlog advanced timestamp < = 0 ) return ; timegap = Timestamp Tz Plus Milliseconds ( t thrd . walsender cxt . last logical xlog advanced timestamp , t thrd . walsender cxt . logical xlog advanced timeout ) ; if ( t thrd . walsender cxt . logical xlog advanced timeout > 0 & & now > = timegap ) { ereport ( LOG , ( errmsg ( \" write xlog of logical slot advanced \" ) ) ) ; log slot advance ( & t thrd . slot cxt . My Replication Slot - > data ) ; t thrd . walsender cxt . last logical xlog advanced timestamp = now ; } }", "predictions": ["this method"], "references": ["check whether the limit is reached in the previous transaction record. if it is, write a new transaction record"], "bleu": 0.00013000471131158705, "rouge_l": 0.0}
{"id": 24, "code": "static void Shut Down Data Rcv Writer ( void ) { volatile Data Rcv Data * datarcv = t thrd . datareceiver cxt . Data Rcv ; Thread Id writer Pid ; int i = 1 ; Spin Lock Acquire ( & datarcv - > mutex ) ; writer Pid = datarcv - > writer Pid ; Spin Lock Release ( & datarcv - > mutex ) ; if ( writer Pid ! = 0 ) ( void ) gs signal send ( writer Pid , SIGTERM ) ; ereport ( LOG , ( errmsg ( \" waiting datarcvwriter : % lu terminate \" , writer Pid ) ) ) ; while ( writer Pid ) { pg usleep ( 10000 L ) ; / / sleep 0 . 01s Spin Lock Acquire ( & datarcv - > mutex ) ; writer Pid = datarcv - > writer Pid ; Spin Lock Release ( & datarcv - > mutex ) ; if ( ( writer Pid ! = 0 ) & & ( i % 2000 = = 0 ) ) { if ( gs signal send ( writer Pid , SIGTERM ) ! = 0 ) { ereport ( WARNING , ( errmsg ( \" datarcvwriter : % lu may be terminated \" , writer Pid ) ) ) ; break ; } i = 1 ; } i + + ; } }", "predictions": ["this function is used to obtain"], "references": ["close the write process of data"], "bleu": 0.18575057999133598, "rouge_l": 0.0}
{"id": 25, "code": "void Sync Rep Check Sync Standby Alive ( void ) { bool sync standby alive = false ; int i = 0 ; if ( ! t thrd . walsender cxt . Wal Snd Ctl - > sync standbys defined | | ! t thrd . walsender cxt . Wal Snd Ctl - > most available sync ) { t thrd . walsender cxt . Wal Snd Ctl - > sync master standalone = false ; return ; } for ( i = 0 ; i < g instance . attr . attr storage . max wal senders ; i + + ) { volatile Wal Snd * walsnd = & t thrd . walsender cxt . Wal Snd Ctl - > walsnds [ i ] ; Spin Lock Acquire ( & walsnd - > mutex ) ; if ( walsnd - > pid ! = 0 & & walsnd - > sync standby priority > 0 & & ( walsnd - > send Role = = SNDROLE PRIMARY DUMMYSTANDBY | | walsnd - > send Role = = SNDROLE PRIMARY STANDBY ) ) { Spin Lock Release ( & walsnd - > mutex ) ; sync standby alive = true ; break ; } Spin Lock Release ( & walsnd - > mutex ) ; } if ( sync standby alive & & t thrd . walsender cxt . Wal Snd Ctl - > sync master standalone ) { ereport ( LOG , ( errmsg ( \" standalone synchronous master now have synchronous standby \" ) ) ) ; t thrd . walsender cxt . Wal Snd Ctl - > sync master standalone = false ; return ; } if ( ! sync standby alive & & ! t thrd . walsender cxt . Wal Snd Ctl - > sync master standalone & & t thrd . walsender cxt . Wal Snd Ctl - > most available sync ) { ereport ( LOG , ( errmsg ( \" synchronous master is now standalone \" ) ) ) ; t thrd . walsender cxt . Wal Snd Ctl - > sync master standalone = true ; for ( i = 0 ; i < NUM SYNC REP WAIT MODE ; i + + ) ( void ) Sync Rep Wake Queue ( true , i ) ; } }", "predictions": ["this method"], "references": ["check if syncrep synchronization standby is active"], "bleu": 0.0524476438328049, "rouge_l": 0.0}
{"id": 26, "code": "bool Heartbeat Client : : Init Connection ( Heartbeat Connection * con , int remote Port ) { int ret = Set Socket No Block ( con - > fd ) ; if ( ret ! = STATUS OK ) { ereport ( COMMERROR , ( errmsg ( \" Set Socket No Block failed . \" ) ) ) ; return false ; } con - > callback = Process Heartbeat Packet Client ; con - > ep Handle = epollfd ; con - > channel Identifier = remote Port ; con - > arg = ( void * ) this ; if ( Event Add ( epollfd , EPOLLIN , con ) ) { ereport ( COMMERROR , ( errmsg ( \" Add listen socket failed [ fd = % d ] . \" , con - > fd ) ) ) ; return false ; } ereport ( LOG , ( errmsg ( \" Add listen socket [ fd = % d ] OK , evnets [ % X ] . \" , con - > fd , EPOLLIN ) ) ) ; if ( ! Send Startup Packet ( con ) ) { Event Del ( con - > ep Handle , con ) ; return false ; } hb Conn = con ; is Connect = true ; return true ; }", "predictions": ["this function is used to"], "references": ["add listening socket block"], "bleu": 0.2295748846661433, "rouge_l": 0.0}
{"id": 27, "code": "static void Wal Rcv Sig Hup Handler ( SIGNAL ARGS ) { t thrd . walreceiver cxt . got SIGHUP = true ; }", "predictions": ["SIGHUP"], "references": ["set a flag to facilitate rereading the configuration file the next time."], "bleu": 1.4044400323157705e-05, "rouge_l": 0.0}
{"id": 28, "code": "static void Data Writer Hash Remove ( bool flushdata ) { # define ERRORDATA FLUSH NUM 5 HASH SEQ STATUS status ; data writer rel * hentry = NULL ; Relation reln ; CUStorage * cu Storage = NULL ; if ( t thrd . datarcvwriter cxt . data writer rel tab = = NULL ) return ; if ( t thrd . datarcvwriter cxt . data Rcv Writer Flush Page Error Count + + > = ERRORDATA FLUSH NUM ) ereport ( PANIC , ( errmsg internal ( \" ERRORDATA FLUSH NUM exceeded \" ) ) ) ; hash seq init ( & status , t thrd . datarcvwriter cxt . data writer rel tab ) ; while ( ( hentry = ( data writer rel * ) hash seq search ( & status ) ) ! = NULL ) { if ( hentry - > key . type = = ROW STORE & & ! g instance . attr . attr storage . enable mix replication ) { reln = hentry - > reln ; if ( flushdata ) { char * path = relpath ( reln - > rd smgr - > smgr rnode , MAIN FORKNUM ) ; # ifdef ENABLE MULTIPLE NODES Lock Rel File Node ( reln - > rd node , Access Exclusive Lock ) ; # endif if ( smgrexists ( reln - > rd smgr , MAIN FORKNUM ) & & Check File Exists ( path ) = = FILE EXIST ) { Flush Relation Buffers ( reln ) ; smgrimmedsync ( reln - > rd smgr , MAIN FORKNUM ) ; } else { ereport ( WARNING , ( errmsg ( \" HA - Data Writer Hash Remove : No File SYNC , rnode % u / % u / % u dose not exists \" , reln - > rd node . spc Node , reln - > rd node . db Node , reln - > rd node . rel Node ) ) ) ; } # ifdef ENABLE MULTIPLE NODES Unlock Rel File Node ( reln - > rd node , Access Exclusive Lock ) ; # endif pfree ext ( path ) ; } Relation Close Smgr ( reln ) ; Free Fake Relcache Entry ( reln ) ; } else if ( hentry - > key . type = = COLUMN STORE ) { cu Storage = hentry - > cu Storage ; if ( cu Storage ! = NULL ) { if ( flushdata ) { # ifdef ENABLE MULTIPLE NODES Lock Rel File Node ( hentry - > key . node , Access Share Lock ) ; # endif if ( cu Storage - > Is Data File Exist ( 0 ) ) { cu Storage - > Flush Data File ( ) ; } # ifdef ENABLE MULTIPLE NODES Unlock Rel File Node ( hentry - > key . node , Access Share Lock ) ; # endif if ( u sess - > attr . attr storage . Ha Module Debug ) ereport ( LOG , ( errmsg ( \" HA - Data Writer Hash Remove : rnode % u / % u / % u , col % d \" , hentry - > key . node . spc Node , hentry - > key . node . db Node , hentry - > key . node . rel Node , hentry - > key . attid ) ) ) ; } DELETE EX ( cu Storage ) ; } } hash search ( t thrd . datarcvwriter cxt . data writer rel tab , ( void * ) & hentry - > key , HASH REMOVE , NULL ) ; } if ( flushdata ) t thrd . datarcvwriter cxt . data Rcv Writer Flush Page Error Count = 0 ; }", "predictions": ["this method"], "references": ["if you need to refresh the data, delete the relationship in the hash table of the current data writer."], "bleu": 0.00013000471131158705, "rouge_l": 0.0}
{"id": 29, "code": "void WSData Rcv Check ( char * data buf , Size nbytes ) { errno t errorno = EOK ; char * cur buf = NULL ; uint32 total len = 0 ; XLog Rec Ptr ref xlog ptr = InvalidXLog Rec Ptr ; cur buf = data buf ; errorno = memcpy s ( & total len , sizeof ( uint32 ) , cur buf , sizeof ( uint32 ) ) ; securec check ( errorno , \" \\ 0 \" , \" \\ 0 \" ) ; cur buf + = sizeof ( uint32 ) ; if ( total len ! = nbytes ) { Assert ( false ) ; ereport ( ERROR , ( errcode ( ERRCODE INVALID PARAMETER VALUE ) , errmsg ( \" the corrupt data total len is % u bytes , the expected len is % lu bytes . \" , total len , nbytes ) ) ) ; } if ( cur buf [ 0 ] ! = ' d ' ) { Assert ( false ) ; ereport ( ERROR , ( errcode ( ERRCODE INVALID PARAMETER VALUE ) , errmsg ( \" the unexpected data flag is % X , the expected data flag is ' d ' . \" , ( unsigned int ) cur buf [ 0 ] ) ) ) ; } cur buf + = 1 ; errorno = memcpy s ( & ref xlog ptr , sizeof ( XLog Rec Ptr ) , cur buf , sizeof ( XLog Rec Ptr ) ) ; securec check ( errorno , \" \\ 0 \" , \" \\ 0 \" ) ; if ( XLog Rec Ptr Is Invalid ( ref xlog ptr ) ) { Assert ( false ) ; ereport ( ERROR , ( errcode ( ERRCODE INVALID PARAMETER VALUE ) , errmsg ( \" the start xlog employed for the wal data is invalid . \" ) ) ) ; } cur buf + = sizeof ( XLog Rec Ptr ) ; errorno = memcpy s ( & ref xlog ptr , sizeof ( XLog Rec Ptr ) , cur buf , sizeof ( XLog Rec Ptr ) ) ; securec check ( errorno , \" \\ 0 \" , \" \\ 0 \" ) ; if ( XLog Rec Ptr Is Invalid ( ref xlog ptr ) ) { Assert ( false ) ; ereport ( ERROR , ( errcode ( ERRCODE INVALID PARAMETER VALUE ) , errmsg ( \" the end xlog employed for the wal data is invalid . \" ) ) ) ; } return ; }", "predictions": ["this function is used to the"], "references": ["this function checks the validity of wal's xlog and the total number of data words"], "bleu": 0.06970452184190923, "rouge_l": 0.26521739130434785}
{"id": 30, "code": "void Init Dummy Data Num ( void ) { DIR * dir = NULL ; struct dirent * de = NULL ; int max num file = 0 ; int min num file = 0 ; char * dirpath = DUMMY STANDBY DATADIR ; errno = 0 ; dir = Allocate Dir ( dirpath ) ; if ( dir = = NULL & & errno = = ENOENT ) { if ( mkdir ( dirpath , S IRWXU ) < 0 ) { ereport ( ERROR , ( errcode for file access ( ) , errmsg ( \" could not create directory \\ \" % s \\ \" : % m \" , dirpath ) ) ) ; } dir = Allocate Dir ( dirpath ) ; } if ( dir = = NULL ) { ereport ( ERROR , ( errcode for file access ( ) , errmsg ( \" could not open directory \\ \" % s \\ \" : % m \" , dirpath ) ) ) ; return ; } while ( ( de = Read Dir ( dir , dirpath ) ) ! = NULL ) { if ( strcmp ( de - > d name , \" . \" ) = = 0 | | strcmp ( de - > d name , \" . . \" ) = = 0 ) continue ; min num file = atoi ( de - > d name ) ; break ; } Free Dir ( dir ) ; dir = Allocate Dir ( dirpath ) ; while ( ( de = Read Dir ( dir , dirpath ) ) ! = NULL ) { if ( strcmp ( de - > d name , \" . \" ) = = 0 | | strcmp ( de - > d name , \" . . \" ) = = 0 ) continue ; max num file = Max ( atoi ( de - > d name ) , max num file ) ; min num file = Min ( atoi ( de - > d name ) , min num file ) ; ereport ( DEBUG5 , ( errmsg ( \" Init Dummy Data Num de - > d name = % s ; max num path = % d ; min num file = % d . \" , de - > d name , max num file , min num file ) ) ) ; } t thrd . datarcvwriter cxt . dummy data writer file num = max num file ; t thrd . datasender cxt . dummy data read file num = min num file ; Free Dir ( dir ) ; }", "predictions": ["function function: < br / >"], "references": ["initialize the standby data queue"], "bleu": 0.18575057999133598, "rouge_l": 0.0}
{"id": 31, "code": "void ut save xlogloc ( const char * xloglocation ) { save xlogloc ( xloglocation ) ; }", "predictions": ["function function: save the"], "references": ["this function is used to save x_ logloc"], "bleu": 0.14628187563941414, "rouge_l": 0.31443298969072164}
{"id": 32, "code": "static void Dummy Standby Data Rcv Write ( char * buf , uint32 nbytes ) { ssize t byteswritten ; char path [ MAXPGPATH ] = { 0 } ; volatile Data Rcv Data * datarcv = t thrd . datareceiver cxt . Data Rcv ; Data Element Header Data dataehdr ; uint32 currentlen = 0 ; int headerlen = sizeof ( Data Element Header Data ) ; uint32 caculatebytes = nbytes ; char * caculatebuf = buf ; int n Ret = 0 ; if ( dummy data writer file offset > = MAX DUMMY DATA FILE | | ( MAX DUMMY DATA FILE - dummy data writer file offset < ( uint32 ) ( nbytes + sizeof ( nbytes ) ) ) ) { ereport ( DEBUG2 , ( errmsg ( \" data file num % u \" , t thrd . datarcvwriter cxt . dummy data writer file num ) ) ) ; t thrd . datarcvwriter cxt . dummy data writer file num + + ; dummy data writer file offset = 0 ; if ( dummy data writer file fd > = 0 ) { close ( dummy data writer file fd ) ; dummy data writer file fd = - 1 ; } } if ( dummy data writer file fd < 0 ) { n Ret = snprintf s ( path , sizeof ( path ) , MAXPGPATH - 1 , \" base / dummy standby / % u \" , t thrd . datarcvwriter cxt . dummy data writer file num ) ; securec check ss c ( n Ret , \" \" , \" \" ) ; dummy data writer file fd = open ( path , O RDWR | O CREAT | PG BINARY , S IRUSR | S IWUSR ) ; if ( dummy data writer file fd < 0 ) ereport ( PANIC , ( errcode for file access ( ) , errmsg ( \" could not create data file \\ \" % s \\ \" , dummy data writer file fd = % d : % m \" , path , dummy data writer file fd ) ) ) ; } while ( caculatebytes > 0 ) { errno t rc = 0 ; rc = memcpy s ( ( void * ) & currentlen , sizeof ( uint32 ) , caculatebuf , sizeof ( uint32 ) ) ; securec check ( rc , \" \" , \" \" ) ; caculatebuf + = sizeof ( uint32 ) ; rc = memcpy s ( ( void * ) & dataehdr , headerlen , caculatebuf , headerlen ) ; securec check ( rc , \" \" , \" \" ) ; caculatebuf + = headerlen ; caculatebuf + = dataehdr . data size ; caculatebytes - = currentlen ; } errno = 0 ; byteswritten = write ( dummy data writer file fd , & nbytes , sizeof ( uint32 ) ) ; if ( byteswritten < ( ssize t ) sizeof ( uint32 ) ) { if ( errno = = 0 ) { errno = ENOSPC ; } ereport ( PANIC , ( errcode for file access ( ) , errmsg ( \" could not write to data file % s buffer len % u , length % u : % m \" , path , nbytes , nbytes ) ) ) ; } errno = 0 ; byteswritten = write ( dummy data writer file fd , buf , nbytes ) ; if ( byteswritten < nbytes ) { if ( errno = = 0 ) errno = ENOSPC ; ereport ( PANIC , ( errcode for file access ( ) , errmsg ( \" could not write to data file % s \" \" at offset % u , length % u : % m \" , path , ( uint32 ) dummy data writer file offset , nbytes ) ) ) ; } dummy data writer file offset = dummy data writer file offset + nbytes + sizeof ( nbytes ) ; if ( u sess - > attr . attr storage . Ha Module Debug ) { ereport ( LOG , ( errmsg ( \" HA - Dummy Standby Data Rcv Write : fileno % u , nbytes % u , queueoffset % u / % u , \" \" dummy data writer file offset % u , dummy data writer file fd % d \" , t thrd . datarcvwriter cxt . dummy data writer file num , nbytes , dataehdr . queue offset . queueid , dataehdr . queue offset . queueoff , dummy data writer file offset , dummy data writer file fd ) ) ) ; } if ( pg fdatasync ( dummy data writer file fd ) ! = 0 ) ereport ( PANIC , ( errcode for file access ( ) , errmsg ( \" could not fdatasync data file num % u , fd % d : % m \" , t thrd . datarcvwriter cxt . dummy data writer file num , dummy data writer file fd ) ) ) ; Spin Lock Acquire ( & datarcv - > mutex ) ; datarcv - > receive Position . queueid = dataehdr . queue offset . queueid ; datarcv - > receive Position . queueoff = dataehdr . queue offset . queueoff ; Spin Lock Release ( & datarcv - > mutex ) ; }", "predictions": ["create a a"], "references": ["it is used to write standby data"], "bleu": 0.11909345107359583, "rouge_l": 0.0}
{"id": 33, "code": "Size heartbeat shmem size ( void ) { Size size = 0 ; size = add size ( size , sizeof ( heartbeat state ) ) ; return size ; }", "predictions": ["add a"], "references": ["this function is used to report the amount of shared memory required for heartbeat"], "bleu": 0.0015837816104164078, "rouge_l": 0.0}
{"id": 34, "code": "static void commit cb wrapper ( Reorder Buffer * cache , Reorder BufferTXN * txn , XLog Rec Ptr commit lsn ) { Logical Decoding Context * ctx = ( Logical Decoding Context * ) cache - > private data ; Logical Error Callback State state ; Error Context Callback errcallback ; Assert ( ! ctx - > fast forward ) ; state . ctx = ctx ; state . callback name = \" commit \" ; state . report location = txn - > final lsn ; errcallback . callback = output plugin error callback ; errcallback . arg = ( void * ) & state ; errcallback . previous = t thrd . log cxt . error context stack ; t thrd . log cxt . error context stack = & errcallback ; ctx - > accept writes = true ; ctx - > write xid = txn - > xid ; ctx - > write location = txn - > end lsn ; ctx - > callbacks . commit cb ( ctx , txn , commit lsn ) ; t thrd . log cxt . error context stack = errcallback . previous ; }", "predictions": ["this function is used to be"], "references": ["this function is used to submit callback wrapper, pass in recoding buffer, record encoding buffer and log receiver"], "bleu": 0.10950068597900019, "rouge_l": 0.3822055137844611}
{"id": 35, "code": "static void Sync Rep Queue Insert ( int mode ) { PGPROC * proc = NULL ; Assert ( mode > = 0 & & mode < NUM SYNC REP WAIT MODE ) ; proc = ( PGPROC * ) SHMQueue Prev ( & ( t thrd . walsender cxt . Wal Snd Ctl - > Sync Rep Queue [ mode ] ) , & ( t thrd . walsender cxt . Wal Snd Ctl - > Sync Rep Queue [ mode ] ) , offsetof ( PGPROC , sync Rep Links ) ) ; while ( proc ! = NULL ) { if ( XLByteLE ( proc - > waitLSN , t thrd . proc - > waitLSN ) ) break ; proc = ( PGPROC * ) SHMQueue Prev ( & ( t thrd . walsender cxt . Wal Snd Ctl - > Sync Rep Queue [ mode ] ) , & ( proc - > sync Rep Links ) , offsetof ( PGPROC , sync Rep Links ) ) ; } if ( proc ! = NULL ) SHMQueue Insert After ( & ( proc - > sync Rep Links ) , & ( t thrd . proc - > sync Rep Links ) ) ; else SHMQueue Insert After ( & ( t thrd . walsender cxt . Wal Snd Ctl - > Sync Rep Queue [ mode ] ) , & ( t thrd . proc - > sync Rep Links ) ) ; }", "predictions": ["this method"], "references": ["insert the incoming pattern into the synchronization delegate queue"], "bleu": 0.019294409903971108, "rouge_l": 0.0}
{"id": 36, "code": "static void Set Wal Rcv Conninfo ( Repl Conn Target conn target ) { volatile Wal Rcv Data * walrcv = t thrd . walreceiverfuncs cxt . Wal Rcv ; volatile Ha Shmem Data * hashmdata = t thrd . postmaster cxt . Ha Shm Data ; Repl Conn Info * conninfo = NULL ; if ( IS DN DUMMY STANDYS MODE ( ) ) { if ( conn target = = REPCONNTARGET PRIMARY ) { ereport ( LOG , ( errmsg ( \" wal receiver get replconninfo [ 1 ] to connect primary . \" ) ) ) ; t thrd . walreceiverfuncs cxt . Wal Repl Index = REPL IDX PRIMARY ; } else if ( walrcv - > dummy Standby Connect Failed ) { if ( t thrd . walreceiverfuncs cxt . Wal Repl Index = = REPL IDX STANDBY ) { Set Failover Failed State ( ) ; } else { conn target = REPCONNTARGET STANDBY ; } ereport ( LOG , ( errmsg ( \" wal receiver get replconninfo [ % d ] to failover to another instance . \" , t thrd . walreceiverfuncs cxt . Wal Repl Index ) ) ) ; } else { ereport ( LOG , ( errmsg ( \" wal receiver get conninfo [ 2 ] for dummystandby . \" ) ) ) ; t thrd . walreceiverfuncs cxt . Wal Repl Index = REPL IDX STANDBY ; } } conninfo = Get Rep Conn Array ( & t thrd . walreceiverfuncs cxt . Wal Repl Index ) ; if ( conninfo ! = NULL ) { int rcs = 0 ; Spin Lock Acquire ( & walrcv - > mutex ) ; rcs = snprintf s ( ( char * ) walrcv - > conninfo , MAXCONNINFO , MAXCONNINFO - 1 , \" host = % s port = % d localhost = % s localport = % d \" , conninfo - > remotehost , conninfo - > remoteport , conninfo - > localhost , conninfo - > localport ) ; securec check ss ( rcs , \" \\ 0 \" , \" \\ 0 \" ) ; walrcv - > conninfo [ MAXCONNINFO - 1 ] = ' \\ 0 ' ; walrcv - > conn errno = NONE ERROR ; walrcv - > conn target = conn target ; walrcv - > conn channel . localservice = conninfo - > localservice ; walrcv - > conn channel . remoteservice = conninfo - > remoteservice ; Spin Lock Release ( & walrcv - > mutex ) ; Spin Lock Acquire ( & hashmdata - > mutex ) ; hashmdata - > current repl = t thrd . walreceiverfuncs cxt . Wal Repl Index ; hashmdata - > disconnect count [ t thrd . walreceiverfuncs cxt . Wal Repl Index ] = 0 ; Spin Lock Release ( & hashmdata - > mutex ) ; t thrd . walreceiverfuncs cxt . Wal Repl Index + + ; } }", "predictions": ["this function is used to obtain"], "references": ["configure wallcv connection information. find the connection target."], "bleu": 0.13309610652103346, "rouge_l": 0.0}
{"id": 37, "code": "XLog Rec Ptr Get Wal Rcv Write Rec Ptr ( XLog Rec Ptr * latest Chunk Start ) { volatile Wal Rcv Data * walrcv = t thrd . walreceiverfuncs cxt . Wal Rcv ; XLog Rec Ptr recptr ; errno t rc = 0 ; Spin Lock Acquire ( & walrcv - > mutex ) ; recptr = walrcv - > received Upto ; if ( latest Chunk Start ! = NULL ) { rc = strncpy s ( ( char * ) latest Chunk Start , sizeof ( XLog Rec Ptr ) , ( char * ) & walrcv - > latest Chunk Start , sizeof ( XLog Rec Ptr ) - 1 ) ; securec check ( rc , \" \\ 0 \" , \" \\ 0 \" ) ; } Spin Lock Release ( & walrcv - > mutex ) ; return recptr ; }", "predictions": ["function function:"], "references": ["this method is used to obtain the record position of the latest block written by the wal receiver"], "bleu": 0.00021434153283064313, "rouge_l": 0.0}
{"id": 38, "code": "static int cmp lsn ( const void * a , const void * b ) { XLog Rec Ptr lsn1 = * ( ( const XLog Rec Ptr * ) a ) ; XLog Rec Ptr lsn2 = * ( ( const XLog Rec Ptr * ) b ) ; if ( ! XLByteLE ( lsn1 , lsn2 ) ) return - 1 ; else if ( XLByteEQ ( lsn1 , lsn2 ) ) return 0 ; else return 1 ; }", "predictions": ["function function: < br / 1"], "references": ["the comparison function of sorting is sorted according to the descending order of lsn."], "bleu": 0.05822753005110548, "rouge_l": 0.09327217125382263}
{"id": 39, "code": "static void XLog Wal Rcv Process Msg ( unsigned char type , char * buf , Size len ) { errno t errorno = EOK ; ereport ( DEBUG5 , ( errmsg ( \" received wal message type : % c \" , type ) ) ) ; switch ( type ) { case ' e ' : { EndXLog Message endXLog Message ; if ( len ! = sizeof ( EndXLog Message ) ) ereport ( ERROR , ( errcode ( ERRCODE PROTOCOL VIOLATION ) , errmsg internal ( \" invalid EndXLog Message message received from Secondary Standby \" ) ) ) ; errorno = memcpy s ( & endXLog Message , sizeof ( EndXLog Message ) , buf , sizeof ( EndXLog Message ) ) ; securec check ( errorno , \" \\ 0 \" , \" \\ 0 \" ) ; Process EndXLog Message ( & endXLog Message ) ; break ; } case ' w ' : { Wal Data Message Header msghdr ; if ( len < sizeof ( Wal Data Message Header ) ) ereport ( ERROR , ( errcode ( ERRCODE PROTOCOL VIOLATION ) , errmsg internal ( \" invalid WAL message received from primary \" ) ) ) ; errorno = memcpy s ( & msghdr , sizeof ( Wal Data Message Header ) , buf , sizeof ( Wal Data Message Header ) ) ; securec check ( errorno , \" \\ 0 \" , \" \\ 0 \" ) ; Process Wal Header Message ( & msghdr ) ; buf + = sizeof ( Wal Data Message Header ) ; len - = sizeof ( Wal Data Message Header ) ; if ( Is Extreme Redo ( ) ) { XLog Wal Rcv Receive In Buf ( buf , len , msghdr . data Start ) ; } else { XLog Wal Rcv Receive ( buf , len , msghdr . data Start ) ; } break ; } case ' d ' : { XLog Wal Rcv Data Page Replication ( buf , len ) ; break ; } case ' k ' : { Primary Keepalive Message keepalive ; if ( len ! = sizeof ( Primary Keepalive Message ) ) ereport ( ERROR , ( errcode ( ERRCODE PROTOCOL VIOLATION ) , errmsg internal ( \" invalid keepalive message received from primary \" ) ) ) ; errorno = memcpy s ( & keepalive , sizeof ( Primary Keepalive Message ) , buf , sizeof ( Primary Keepalive Message ) ) ; securec check ( errorno , \" \\ 0 \" , \" \\ 0 \" ) ; Process Keepalive Message ( & keepalive ) ; if ( keepalive . reply Requested ) XLog Wal Rcv Send Reply ( true , false ) ; break ; } case ' p ' : { Primary Switch Response Message response ; if ( len ! = sizeof ( Primary Switch Response Message ) ) ereport ( ERROR , ( errcode ( ERRCODE PROTOCOL VIOLATION ) , errmsg internal ( \" invalid switchover response message received from primary \" ) ) ) ; errorno = memcpy s ( & response , sizeof ( Primary Switch Response Message ) , buf , sizeof ( Primary Switch Response Message ) ) ; securec check ( errorno , \" \\ 0 \" , \" \\ 0 \" ) ; Process Wal Sndr Message ( & response . wal End , response . send Time ) ; ereport ( LOG , ( errmsg ( \" received switchover response message from primary \" ) ) ) ; Process Switch Response ( response . switch Response ) ; break ; } case ' m ' : { Config Modify Time Message primary config file ; if ( len < sizeof ( Config Modify Time Message ) ) ereport ( ERROR , ( errcode ( ERRCODE PROTOCOL VIOLATION ) , errmsg internal ( \" invalid config file message \" ) ) ) ; errorno = memcpy s ( & primary config file , sizeof ( Config Modify Time Message ) , buf , sizeof ( Config Modify Time Message ) ) ; securec check ( errorno , \" \\ 0 \" , \" \\ 0 \" ) ; t thrd . walreceiver cxt . Primary config modify time = primary config file . config modify time ; buf + = sizeof ( Config Modify Time Message ) ; len - = sizeof ( Config Modify Time Message ) ; ereport ( LOG , ( errmsg ( \" walreceiver received gaussdb config file size : % lu \" , len ) ) ) ; if ( true ! = Process Config File Message ( buf , len ) ) { ereport ( LOG , ( errmsg ( \" walreceiver update config file failed \" ) ) ) ; } break ; } case ' x ' : { RmXLog Message rmXLog Message ; if ( len ! = sizeof ( RmXLog Message ) ) ereport ( ERROR , ( errcode ( ERRCODE PROTOCOL VIOLATION ) , errmsg internal ( \" invalid RmXLog message received from primary \" ) ) ) ; errorno = memcpy s ( & rmXLog Message , sizeof ( RmXLog Message ) , buf , sizeof ( RmXLog Message ) ) ; securec check ( errorno , \" \\ 0 \" , \" \\ 0 \" ) ; Process RmXLog Message ( & rmXLog Message ) ; break ; } default : ereport ( ERROR , ( errcode ( ERRCODE PROTOCOL VIOLATION ) , errmsg internal ( \" invalid replication message type % c \" , type ) ) ) ; } }", "predictions": ["get the information of the"], "references": ["accept the message from the xlog stream and process it."], "bleu": 0.11115018927487523, "rouge_l": 0.2515463917525773}
{"id": 40, "code": "static void req Shutdown Handler ( SIGNAL ARGS ) { int save Errno = errno ; t thrd . walrcvwriter cxt . shutdown Requested = true ; if ( t thrd . proc ) { Set Latch ( & t thrd . proc - > proc Latch ) ; } errno = save Errno ; }", "predictions": ["this function is used to save"], "references": ["the static method is to stop the manager"], "bleu": 0.17516432701748888, "rouge_l": 0.2785388127853881}
{"id": 41, "code": "void Wal Snd Set State ( Wal Snd State state ) { volatile Wal Snd * walsnd = t thrd . walsender cxt . My Wal Snd ; Assert ( AM WAL SENDER ) ; if ( walsnd - > state = = state ) return ; Spin Lock Acquire ( & walsnd - > mutex ) ; walsnd - > state = state ; if ( state = = WALSNDSTATE CATCHUP ) walsnd - > catchup Time [ 0 ] = Get Current Timestamp ( ) ; else if ( state = = WALSNDSTATE STREAMING ) walsnd - > catchup Time [ 1 ] = Get Current Timestamp ( ) ; Spin Lock Release ( & walsnd - > mutex ) ; }", "predictions": ["this function is used to the"], "references": ["sets the status of the current walsender (called in walsender only)."], "bleu": 0.09600096733558854, "rouge_l": 0.1117216117216117}
{"id": 42, "code": "int Data Rcv Write ( void ) { volatile Data Rcv Data * datarcv = t thrd . datareceiver cxt . Data Rcv ; char * write Buf = NULL ; uint32 nbytes = 0 ; uint32 remainbytes = 0 ; Data Queue Ptr curstartpos ; Data Queue Ptr curendpos ; START CRIT SECTION ( ) ; LWLock Acquire ( Rcv Write Lock , LW EXCLUSIVE ) ; Spin Lock Acquire ( & datarcv - > mutex ) ; curstartpos . queueid = datarcv - > local Write Position . queueid ; curstartpos . queueoff = datarcv - > local Write Position . queueoff ; Spin Lock Release ( & datarcv - > mutex ) ; nbytes = Get From Data Queue ( write Buf , g instance . attr . attr storage . Data Queue Buf Size * 1024 , curstartpos , curendpos , true , t thrd . dataqueue cxt . Data Writer Queue ) ; if ( nbytes = = 0 ) { LWLock Release ( Rcv Write Lock ) ; END CRIT SECTION ( ) ; return 0 ; } if ( dummy Standby Mode ) Dummy Standby Do Data Write ( write Buf , nbytes ) ; else remainbytes = Do Data Write ( write Buf , nbytes ) ; smgrcloseall ( ) ; nbytes - = remainbytes ; Spin Lock Acquire ( & datarcv - > mutex ) ; datarcv - > local Write Position . queueid = curstartpos . queueid ; datarcv - > local Write Position . queueoff = curstartpos . queueoff ; DQByte Advance ( datarcv - > local Write Position , nbytes ) ; Spin Lock Release ( & datarcv - > mutex ) ; Pop From Data Queue ( ( ( Data Rcv Data * ) datarcv ) - > local Write Position , t thrd . dataqueue cxt . Data Writer Queue ) ; LWLock Release ( Rcv Write Lock ) ; END CRIT SECTION ( ) ; return nbytes ; }", "predictions": ["this method"], "references": ["write data to disk."], "bleu": 0.23505403213046533, "rouge_l": 0.0}
{"id": 43, "code": "static void Data Rcv Stream Connect ( char * conninfo ) { char conninfo repl [ MAXCONNINFO + 75 ] = { 0 } ; char * primary sysid = NULL ; char standby sysid [ 32 ] ; Time LineID primary tli ; Time LineID standby tli ; PGresult * res = NULL ; Server Mode primary mode ; int rc = EOK ; if ( dummy Standby Mode ) { rc = snprintf s ( conninfo repl , sizeof ( conninfo repl ) , sizeof ( conninfo repl ) - 1 , \" % s dbname = replication replication = data \" \" fallback application name = dummystandby \" \" connect timeout = % d \" , conninfo , u sess - > attr . attr storage . wal receiver connect timeout ) ; } else { rc = snprintf s ( conninfo repl , sizeof ( conninfo repl ) , sizeof ( conninfo repl ) - 1 , \" % s dbname = replication replication = data \" \" fallback application name = % s \" \" connect timeout = % d \" , conninfo , ( u sess - > attr . attr common . application name & & strlen ( u sess - > attr . attr common . application name ) > 0 ) ? u sess - > attr . attr common . application name : \" datareceiver \" , u sess - > attr . attr storage . wal receiver connect timeout ) ; } securec check ss ( rc , \" \" , \" \" ) ; ereport ( LOG , ( errmsg ( \" data streaming replication connecting to primary : % s \" , conninfo repl ) ) ) ; t thrd . datareceiver cxt . data Streaming Conn = PQconnectdb ( conninfo repl ) ; if ( PQstatus ( t thrd . datareceiver cxt . data Streaming Conn ) ! = CONNECTION OK ) ereport ( ERROR , ( errcode ( ERRCODE CONNECTION TIMED OUT ) , errmsg ( \" data receiver could not connect to the primary server : % s \" , PQerror Message ( t thrd . datareceiver cxt . data Streaming Conn ) ) ) ) ; ereport ( LOG , ( errmsg ( \" data streaming replication connected to primary : % s success . \" , conninfo ) ) ) ; if ( ! dummy Standby Mode ) { if ( ! t thrd . datareceiver cxt . Am Data Receiver For Dummy Standby ) { res = PQexec ( t thrd . datareceiver cxt . data Streaming Conn , \" IDENTIFY MODE \" ) ; if ( PQresult Status ( res ) ! = PGRES TUPLES OK ) { PQclear ( res ) ; ereport ( ERROR , ( errcode ( ERRCODE INVALID STATUS ) , errmsg ( \" could not receive the ongoing mode infomation from \" \" the primary server : % s \" , PQerror Message ( t thrd . datareceiver cxt . data Streaming Conn ) ) ) ) ; } if ( PQnfields ( res ) ! = 1 | | PQntuples ( res ) ! = 1 ) { int ntuples = PQntuples ( res ) ; int nfields = PQnfields ( res ) ; PQclear ( res ) ; ereport ( ERROR , ( errcode ( ERRCODE INVALID STATUS ) , errmsg ( \" invalid response from primary server \" ) , errdetail ( \" Expected 1 tuple with 1 fields , got % d tuples with % d fields . \" , ntuples , nfields ) ) ) ; } primary mode = ( Server Mode ) pg strtoint32 ( PQgetvalue ( res , 0 , 0 ) ) ; if ( primary mode ! = PRIMARY MODE ) { PQclear ( res ) ; ereport ( ERROR , ( errcode ( ERRCODE INVALID STATUS ) , errmsg ( \" the mode of the remote server must be primary , current is % s \" , wal get role string ( primary mode ) ) ) ) ; } PQclear ( res ) ; } res = PQexec ( t thrd . datareceiver cxt . data Streaming Conn , \" IDENTIFY SYSTEM \" ) ; if ( PQresult Status ( res ) ! = PGRES TUPLES OK ) { PQclear ( res ) ; ereport ( ERROR , ( errcode ( ERRCODE INVALID STATUS ) , errmsg ( \" could not receive database system identifier and timeline ID from \" \" the primary server : % s \" , PQerror Message ( t thrd . datareceiver cxt . data Streaming Conn ) ) ) ) ; } if ( PQnfields ( res ) < 2 | | PQntuples ( res ) ! = 1 ) { int ntuples = PQntuples ( res ) ; int nfields = PQnfields ( res ) ; PQclear ( res ) ; ereport ( ERROR , ( errcode ( ERRCODE INVALID STATUS ) , errmsg ( \" invalid response from primary server \" ) , errdetail ( \" Could not identify system : got % d rows and % d fields , expected % d rows and % d or more fields . \" , ntuples , nfields , 2 , 1 ) ) ) ; } primary sysid = PQgetvalue ( res , 0 , 0 ) ; primary tli = pg strtoint32 ( PQgetvalue ( res , 0 , 1 ) ) ; rc = snprintf s ( standby sysid , sizeof ( standby sysid ) , sizeof ( standby sysid ) - 1 , UINT64 FORMAT , Get System Identifier ( ) ) ; securec check ss ( rc , \" \" , \" \" ) ; if ( strcmp ( primary sysid , standby sysid ) ! = 0 ) { primary sysid = pstrdup ( primary sysid ) ; PQclear ( res ) ; ereport ( ERROR , ( errcode ( ERRCODE INVALID STATUS ) , errmsg ( \" database system identifier differs between the primary and standby \" ) , errdetail ( \" The primary ' s identifier is % s , the standby ' s identifier is % s . \" , primary sysid , standby sysid ) ) ) ; } standby tli = Get Recovery TargetTLI ( ) ; PQclear ( res ) ; if ( primary tli ! = standby tli ) { ereport ( ERROR , ( errcode ( ERRCODE INVALID STATUS ) , errmsg ( \" timeline % u of the primary does not match recovery target timeline % u \" , primary tli , standby tli ) ) ) ; } t thrd . xlog cxt . This Time LineID = primary tli ; } res = PQexec ( t thrd . datareceiver cxt . data Streaming Conn , \" START REPLICATION DATA \" ) ; if ( PQresult Status ( res ) ! = PGRES COPY BOTH ) { PQclear ( res ) ; ereport ( ERROR , ( errcode ( ERRCODE INVALID STATUS ) , errmsg ( \" could not start DATA streaming : % s \" , PQerror Message ( t thrd . datareceiver cxt . data Streaming Conn ) ) ) ) ; } PQclear ( res ) ; ereport ( LOG , ( errmsg ( \" data streaming replication successfully connected to primary . \" ) ) ) ; }", "predictions": ["function function: < br / >"], "references": ["connection of data sink stream"], "bleu": 0.18575057999133598, "rouge_l": 0.0}
{"id": 44, "code": "static void Data Rcv Stream Send Files ( const char * buffer , int nbytes ) { if ( PQput Copy Data ( t thrd . datareceiver cxt . data Streaming Conn , buffer , nbytes ) < = 0 | | PQflush ( t thrd . datareceiver cxt . data Streaming Conn ) ) ereport ( ERROR , ( errcode ( ERRCODE INVALID STATUS ) , errmsg ( \" could not send data to DATA stream : % s \" , PQerror Message ( t thrd . datareceiver cxt . data Streaming Conn ) ) ) ) ; }", "predictions": ["this function is"], "references": ["send a message to the data stream. < br / > report errors."], "bleu": 0.016117545932670774, "rouge_l": 0.0}
{"id": 45, "code": "static const char * Wal Snd Get State String ( Wal Snd State state ) { switch ( state ) { case WALSNDSTATE STARTUP : return \" Startup \" ; case WALSNDSTATE BACKUP : return \" Backup \" ; case WALSNDSTATE CATCHUP : return \" Catchup \" ; case WALSNDSTATE STREAMING : return \" Streaming \" ; } return \" Unknown \" ; }", "predictions": ["get the state"], "references": ["this function returns a string constant that represents the state."], "bleu": 0.05210158044842422, "rouge_l": 0.14022988505747128}
{"id": 46, "code": "void Data Rcv Shmem Init ( void ) { bool found = false ; errno t rc = 0 ; t thrd . datareceiver cxt . Data Rcv = ( Data Rcv Data * ) Shmem Init Struct ( \" Data Receiver Ctl \" , Data Rcv Shmem Size ( ) , & found ) ; if ( ! found ) { rc = memset s ( t thrd . datareceiver cxt . Data Rcv , Data Rcv Shmem Size ( ) , 0 , Data Rcv Shmem Size ( ) ) ; securec check ( rc , \" \" , \" \" ) ; Spin Lock Init ( & t thrd . datareceiver cxt . Data Rcv - > mutex ) ; } }", "predictions": ["this function is used to obtain"], "references": ["locate and initialize the shared memory required by the receiver"], "bleu": 0.09536752763778475, "rouge_l": 0.0}
{"id": 47, "code": "void Sync Rep Release Waiters ( void ) { volatile Wal Snd Ctl Data * walsndctl = t thrd . walsender cxt . Wal Snd Ctl ; XLog Rec Ptr receive Ptr ; XLog Rec Ptr write Ptr ; XLog Rec Ptr flush Ptr ; XLog Rec Ptr replay Ptr ; int numreceive = 0 ; int numwrite = 0 ; int numflush = 0 ; bool got recptr = false ; bool am sync = false ; if ( t thrd . walsender cxt . My Wal Snd - > sync standby priority = = 0 | | t thrd . walsender cxt . My Wal Snd - > state < WALSNDSTATE STREAMING | | XLByteEQ ( t thrd . walsender cxt . My Wal Snd - > flush , InvalidXLog Rec Ptr ) ) { t thrd . syncrep cxt . announce next takeover = true ; return ; } ( void ) LWLock Acquire ( Sync Rep Lock , LW EXCLUSIVE ) ; got recptr = Sync Rep Get Sync Rec Ptr ( & receive Ptr , & write Ptr , & flush Ptr , & replay Ptr , & am sync ) ; if ( t thrd . syncrep cxt . announce next takeover & & am sync ) { t thrd . syncrep cxt . announce next takeover = false ; if ( t thrd . syncrep cxt . Sync Rep Config - > syncrep method = = SYNC REP PRIORITY ) { ereport ( LOG , ( errmsg ( \" standby \\ \" % s \\ \" is now a synchronous standby with priority % d \" , u sess - > attr . attr common . application name , t thrd . walsender cxt . My Wal Snd - > sync standby priority ) ) ) ; } else { ereport ( LOG , ( errmsg ( \" standby \\ \" % s \\ \" is now a candidate for quorum synchronous standby \" , u sess - > attr . attr common . application name ) ) ) ; } } if ( ! got recptr | | ! am sync ) { LWLock Release ( Sync Rep Lock ) ; t thrd . syncrep cxt . announce next takeover = ! am sync ; return ; } if ( XLByteLT ( walsndctl - > lsn [ SYNC REP WAIT RECEIVE ] , receive Ptr ) ) { walsndctl - > lsn [ SYNC REP WAIT RECEIVE ] = t thrd . walsender cxt . My Wal Snd - > receive ; numreceive = Sync Rep Wake Queue ( false , SYNC REP WAIT RECEIVE ) ; } if ( XLByteLT ( walsndctl - > lsn [ SYNC REP WAIT WRITE ] , write Ptr ) ) { walsndctl - > lsn [ SYNC REP WAIT WRITE ] = t thrd . walsender cxt . My Wal Snd - > write ; numwrite = Sync Rep Wake Queue ( false , SYNC REP WAIT WRITE ) ; } if ( XLByteLT ( walsndctl - > lsn [ SYNC REP WAIT FLUSH ] , flush Ptr ) ) { walsndctl - > lsn [ SYNC REP WAIT FLUSH ] = t thrd . walsender cxt . My Wal Snd - > flush ; numflush = Sync Rep Wake Queue ( false , SYNC REP WAIT FLUSH ) ; } if ( XLByteLT ( walsndctl - > lsn [ SYNC REP WAIT REPALY ] , replay Ptr ) ) { walsndctl - > lsn [ SYNC REP WAIT REPALY ] = t thrd . walsender cxt . My Wal Snd - > apply ; numflush = Sync Rep Wake Queue ( false , SYNC REP WAIT REPALY ) ; } LWLock Release ( Sync Rep Lock ) ; ereport ( DEBUG3 , ( errmsg ( \" released % d procs up to receive % X / % X , % d procs up to write % X / % X , % d procs up to flush % X / % X \" , numreceive , ( uint32 ) ( receive Ptr > > 32 ) , ( uint32 ) receive Ptr , numwrite , ( uint32 ) ( write Ptr > > 32 ) , ( uint32 ) write Ptr , numflush , ( uint32 ) ( flush Ptr > > 32 ) , ( uint32 ) flush Ptr ) ) ) ; }", "predictions": ["this method"], "references": ["update the log sequence number on each queue according to the latest status"], "bleu": 0.002611214429237235, "rouge_l": 0.0}
{"id": 48, "code": "void Wal Rcv Shmem Init ( void ) { bool found = false ; errno t rc = 0 ; t thrd . walreceiverfuncs cxt . Wal Rcv = ( Wal Rcv Data * ) Shmem Init Struct ( \" Wal Receiver Ctl \" , Wal Rcv Shmem Size ( ) , & found ) ; if ( ! found ) { rc = memset s ( t thrd . walreceiverfuncs cxt . Wal Rcv , Wal Rcv Shmem Size ( ) , 0 , Wal Rcv Shmem Size ( ) ) ; securec check ( rc , \" \\ 0 \" , \" \\ 0 \" ) ; t thrd . walreceiverfuncs cxt . Wal Rcv - > wal Rcv State = WALRCV STOPPED ; t thrd . walreceiverfuncs cxt . Wal Rcv - > node state = NODESTATE NORMAL ; t thrd . walreceiverfuncs cxt . Wal Rcv - > conn errno = NONE ERROR ; t thrd . walreceiverfuncs cxt . Wal Rcv - > ntries = 0 ; t thrd . walreceiverfuncs cxt . Wal Rcv - > dummy Standby Sync Percent = 0 ; t thrd . walreceiverfuncs cxt . Wal Rcv - > dummy Standby Connect Failed = false ; Spin Lock Init ( & t thrd . walreceiverfuncs cxt . Wal Rcv - > mutex ) ; } }", "predictions": ["this method"], "references": ["allocates and initializes shared memory associated with wallreceiver"], "bleu": 0.031811104014284386, "rouge_l": 0.0}
{"id": 49, "code": "bool Heartbeat Client : : Send Startup Packet ( const Heartbeat Connection * con ) const { ereport ( DEBUG2 , ( errmsg ( \" [ client ] send statup packet \" ) ) ) ; Heartbeat Startup Packet packet ; packet . channel Identifier = Get Channel Id ( con - > remote Host , con - > channel Identifier ) ; packet . send Time = Get Current Timestamp ( ) ; return Send Packet ( con , ( char * ) ( & packet ) , sizeof ( Heartbeat Startup Packet ) ) ; }", "predictions": ["get the"], "references": ["the sending status packet contains two variables: local heartbeat port number and sending time"], "bleu": 0.00188344435971766, "rouge_l": 0.11010830324909747}
{"id": 50, "code": "static void Data Snd Shutdown Handler ( SIGNAL ARGS ) { int save errno = errno ; t thrd . datasender cxt . datasender shutdown requested = true ; if ( t thrd . datasender cxt . My Data Snd ) Set Latch ( & t thrd . datasender cxt . My Data Snd - > latch ) ; Interrupt Pending = true ; t thrd . int cxt . Proc Die Pending = true ; errno = save errno ; }", "predictions": ["this function is used to save"], "references": ["set the flag to close the program"], "bleu": 0.1869843520537038, "rouge_l": 0.1517412935323383}
{"id": 51, "code": "void Remove Conn ( Heartbeat Connection * con ) { if ( con ! = NULL ) { Event Del ( con - > ep Handle , con ) ; Conn Close And Free ( con ) ; } }", "predictions": ["Remove"], "references": ["remove join"], "bleu": 0.30934850332660563, "rouge_l": 0.0}
{"id": 52, "code": "void Data Rcv Writer Main ( void ) { sigjmp buf local Sigjmp Buf ; Memory Context datarcv Writer Context ; t thrd . xlog cxt . In Recovery = true ; ereport ( LOG , ( errmsg ( \" datarcvwriter thread started \" ) ) ) ; ( void ) gspqsignal ( SIGHUP , Data Rcv Writer Sig Hup Handler ) ; ( void ) gspqsignal ( SIGINT , SIG IGN ) ; ( void ) gspqsignal ( SIGTERM , Req Shutdown Handler ) ; ( void ) gspqsignal ( SIGQUIT , Data Rcv Writer Quick Die ) ; ( void ) gspqsignal ( SIGALRM , SIG IGN ) ; ( void ) gspqsignal ( SIGPIPE , SIG IGN ) ; ( void ) gspqsignal ( SIGUSR1 , SIG IGN ) ; ( void ) gspqsignal ( SIGUSR2 , SIG IGN ) ; ( void ) gspqsignal ( SIGCHLD , SIG DFL ) ; ( void ) gspqsignal ( SIGTTIN , SIG DFL ) ; ( void ) gspqsignal ( SIGTTOU , SIG DFL ) ; ( void ) gspqsignal ( SIGCONT , SIG DFL ) ; ( void ) gspqsignal ( SIGWINCH , SIG DFL ) ; ( void ) sigdelset ( & t thrd . libpq cxt . Block Sig , SIGQUIT ) ; on shmem exit ( Shutdown Data Rcv Writer , 0 ) ; t thrd . utils cxt . Current Resource Owner = Resource Owner Create ( NULL , \" Data Receive Writer \" ) ; datarcv Writer Context = Alloc Set Context Create ( t thrd . top mem cxt , \" Data Receive Writer \" , ALLOCSET DEFAULT MINSIZE , ALLOCSET DEFAULT INITSIZE , ALLOCSET DEFAULT MAXSIZE ) ; ( void ) Memory Context Switch To ( datarcv Writer Context ) ; if ( dummy Standby Mode ) { Init Dummy Data Num ( ) ; t thrd . datarcvwriter cxt . dummy data writer file num + + ; dummy data writer file offset = 0 ; } int cur Try Counter = 0 ; int * old Try Counter = NULL ; if ( sigsetjmp ( local Sigjmp Buf , 1 ) ! = 0 ) { gstrace tryblock exit ( true , old Try Counter ) ; t thrd . log cxt . error context stack = NULL ; HOLD INTERRUPTS ( ) ; Emit Error Report ( ) ; Abort Async ListIO ( ) ; LWLock Release All ( ) ; Abort BufferIO ( ) ; Unlock Buffers ( ) ; Resource Owner Release ( t thrd . utils cxt . Current Resource Owner , RESOURCE RELEASE BEFORE LOCKS , false , true ) ; AtEOXact Buffers ( false ) ; Lock Error Cleanup ( ) ; Lock Release Current Owner ( ) ; AtEOXact Files ( ) ; AtEOXact Hash Tables ( false ) ; ( void ) Memory Context Switch To ( datarcv Writer Context ) ; Flush Error State ( ) ; Data Writer Hash Remove ( false ) ; Memory Context Reset And Delete Children ( datarcv Writer Context ) ; RESUME INTERRUPTS ( ) ; pg usleep ( 1000000 L ) ; smgrcloseall ( ) ; } old Try Counter = gstrace tryblock entry ( & cur Try Counter ) ; t thrd . log cxt . PG exception stack = & local Sigjmp Buf ; gs signal setmask ( & t thrd . libpq cxt . Un Block Sig , NULL ) ; ( void ) gs signal unblock sigusr2 ( ) ; if ( ! Recovery In Progress ( ) ) ereport ( FATAL , ( errmsg ( \" cannot continue Data streaming , recovery has already ended \" ) ) ) ; t thrd . xlog cxt . This Time LineID = Get Recovery TargetTLI ( ) ; Set Data Rcv Writer Latch ( ) ; Data Writer Hash Create ( ) ; for ( ; ; ) { int rc ; Reset Latch ( & t thrd . proc - > proc Latch ) ; if ( t thrd . datarcvwriter cxt . gotSIGHUP ) { t thrd . datarcvwriter cxt . gotSIGHUP = false ; Process Config File ( PGC SIGHUP ) ; } while ( ! t thrd . datarcvwriter cxt . shutdown Requested & & Data Rcv Write ( ) > 0 ) ; if ( t thrd . datarcvwriter cxt . shutdown Requested ) { ereport ( LOG , ( errmsg ( \" datarcvwriter thread shut down \" ) ) ) ; u sess - > attr . attr common . Exit On Any Error = true ; proc exit ( 0 ) ; } rc = Wait Latch ( & t thrd . proc - > proc Latch , WL LATCH SET | WL TIMEOUT | WL POSTMASTER DEATH , ( long ) 1000 ) ; if ( rc & WL POSTMASTER DEATH ) { ereport ( LOG , ( errmsg ( \" datarcvwriter thread shut down with exit code 1 \" ) ) ) ; gs thread exit ( 1 ) ; } } }", "predictions": ["this method"], "references": ["the main part of receiving and reading data"], "bleu": 0.031811104014284386, "rouge_l": 0.0}
{"id": 53, "code": "static void Data Rcv Stream Disconnect ( void ) { PQfinish ( t thrd . datareceiver cxt . data Streaming Conn ) ; t thrd . datareceiver cxt . data Streaming Conn = NULL ; }", "predictions": ["function function:"], "references": ["disconnect from data stream host"], "bleu": 0.14256747717620566, "rouge_l": 0.0}
{"id": 54, "code": "static bool Sync Rep Get Sync Rec Ptr ( XLog Rec Ptr * receive Ptr , XLog Rec Ptr * write Ptr , XLog Rec Ptr * flush Ptr , XLog Rec Ptr * replay Ptr , bool * am sync ) { List * sync standbys = NIL ; * receive Ptr = InvalidXLog Rec Ptr ; * write Ptr = InvalidXLog Rec Ptr ; * flush Ptr = InvalidXLog Rec Ptr ; * replay Ptr = InvalidXLog Rec Ptr ; * am sync = false ; sync standbys = Sync Rep Get Sync Standbys ( am sync ) ; if ( ! ( * am sync ) | | t thrd . syncrep cxt . Sync Rep Config = = NULL | | list length ( sync standbys ) < t thrd . syncrep cxt . Sync Rep Config - > num sync ) { list free ( sync standbys ) ; return false ; } if ( t thrd . syncrep cxt . Sync Rep Config - > syncrep method = = SYNC REP PRIORITY ) { Sync Rep Get Oldest Sync Rec Ptr ( receive Ptr , write Ptr , flush Ptr , replay Ptr , sync standbys ) ; } else { Sync Rep Get Nth Latest Sync Rec Ptr ( receive Ptr , write Ptr , flush Ptr , replay Ptr , sync standbys , t thrd . syncrep cxt . Sync Rep Config - > num sync ) ; } list free ( sync standbys ) ; return true ; }", "predictions": ["this method"], "references": ["the write, refresh and application positions of synchronization in synchronization standby are calculated."], "bleu": 0.002611214429237235, "rouge_l": 0.0}
{"id": 55, "code": "void Check Point Replication Slots ( void ) { int i ; int n Ret = 0 ; ereport ( DEBUG1 , ( errmsg ( \" performing replication slot checkpoint \" ) ) ) ; LWLock Acquire ( Replication Slot Allocation Lock , LW SHARED ) ; for ( i = 0 ; i < g instance . attr . attr storage . max replication slots ; i + + ) { Replication Slot * s = & t thrd . slot cxt . Replication Slot Ctl - > replication slots [ i ] ; char path [ MAXPGPATH ] ; if ( ! s - > in use ) continue ; n Ret = snprintf s ( path , MAXPGPATH , MAXPGPATH - 1 , \" pg replslot / % s \" , Name Str ( s - > data . name ) ) ; securec check ss ( n Ret , \" \\ 0 \" , \" \\ 0 \" ) ; if ( unlikely ( Check File Exists ( path ) = = FILE NOT EXIST ) ) { Create Slot On Disk ( s ) ; } Save Slot To Path ( s , path , LOG ) ; } LWLock Release ( Replication Slot Allocation Lock ) ; }", "predictions": ["this function is used to be"], "references": ["flush all replication tanks"], "bleu": 0.18575057999133598, "rouge_l": 0.0}
{"id": 56, "code": "static void Process Standby Message ( void ) { char msgtype ; reset String Info ( t thrd . walsender cxt . reply message ) ; if ( pq getmessage ( t thrd . walsender cxt . reply message , 0 ) ) { ereport ( COMMERROR , ( errcode ( ERRCODE PROTOCOL VIOLATION ) , errmsg ( \" unexpected EOF on standby connection \" ) ) ) ; proc exit ( 0 ) ; } msgtype = pq getmsgbyte ( t thrd . walsender cxt . reply message ) ; switch ( msgtype ) { case ' r ' : Process Standby Reply Message ( ) ; break ; case ' h ' : Process StandbyHSFeedback Message ( ) ; break ; case ' s ' : Process Standby Switch Request Message ( ) ; break ; case ' A ' : Process Standby File Time Message ( ) ; break ; default : ereport ( COMMERROR , ( errcode ( ERRCODE PROTOCOL VIOLATION ) , errmsg ( \" unexpected message type \\ \" % d \\ \" \" , msgtype ) ) ) ; proc exit ( 0 ) ; } }", "predictions": ["this function"], "references": ["accept to process the status update message received from the ready server"], "bleu": 0.004305164771842524, "rouge_l": 0.0}
{"id": 57, "code": "Size Wal Rcv Shmem Size ( void ) { Size size = 0 ; size = add size ( size , sizeof ( Wal Rcv Data ) ) ; return size ; }", "predictions": ["this function"], "references": ["report the shared memory space required by wallrcvshmeninit"], "bleu": 0.031811104014284386, "rouge_l": 0.0}
{"id": 58, "code": "static bool Database Hash Search ( Oid spcoid , Oid dboid ) { HASH SEQ STATUS status ; data writer rel * hentry = NULL ; if ( t thrd . datarcvwriter cxt . data writer rel tab = = NULL ) return false ; hash seq init ( & status , t thrd . datarcvwriter cxt . data writer rel tab ) ; while ( ( hentry = ( data writer rel * ) hash seq search ( & status ) ) ! = NULL ) { if ( hentry - > key . node . spc Node = = spcoid & & hentry - > key . node . db Node = = dboid ) { hash seq term ( & status ) ; return true ; } } return false ; }", "predictions": ["this function is used to be"], "references": ["divide keywords, provide a complete class in the application, and provide access and operation for other classes."], "bleu": 0.02969775556317068, "rouge_l": 0.0}
{"id": 59, "code": "static void Conn Param Free ( Conn Param * param ) { if ( param = = NULL ) { return ; } if ( param - > remote Ip ! = NULL ) { pfree ( param - > remote Ip ) ; param - > remote Ip = NULL ; } if ( param - > local Ip ! = NULL ) { pfree ( param - > local Ip ) ; param - > local Ip = NULL ; } pfree ( param ) ; param = NULL ; }", "predictions": ["this function is used to the file"], "references": ["function that releases connection parameters."], "bleu": 0.18575057999133598, "rouge_l": 0.17183098591549298}
{"id": 60, "code": "static void Data Snd Shutdown ( void ) { if ( t thrd . postgres cxt . where To Send Output = = Dest Remote ) t thrd . postgres cxt . where To Send Output = Dest None ; proc exit ( 0 ) ; abort ( ) ; }", "predictions": ["this static"], "references": ["handle client aborts in an orderly manner."], "bleu": 0.0524476438328049, "rouge_l": 0.0}
{"id": 61, "code": "static void Shutdown Data Rcv Writer ( int code , Datum arg ) { Lock Error Cleanup ( ) ; Lock Release Current Owner ( ) ; Empty Data Rcv Writer Latch ( ) ; }", "predictions": ["function function: < br / void"], "references": ["this function is called when datarcvwritermain ends"], "bleu": 0.1869843520537038, "rouge_l": 0.1517412935323383}
{"id": 62, "code": "static List * Sync Rep Get Sync Standbys Priority ( bool * am sync ) { List * result = NIL ; List * pending = NIL ; int lowest priority ; int next highest priority ; int this priority ; int priority ; int i ; bool am in pending = false ; volatile Wal Snd * walsnd = NULL ; Assert ( t thrd . syncrep cxt . Sync Rep Config - > syncrep method = = SYNC REP PRIORITY ) ; lowest priority = t thrd . syncrep cxt . Sync Rep Config - > nmembers ; next highest priority = lowest priority + 1 ; for ( i = 0 ; i < g instance . attr . attr storage . max wal senders ; i + + ) { walsnd = & t thrd . walsender cxt . Wal Snd Ctl - > walsnds [ i ] ; if ( walsnd - > pid = = 0 ) continue ; if ( walsnd - > state ! = WALSNDSTATE STREAMING ) continue ; this priority = walsnd - > sync standby priority ; if ( this priority = = 0 ) continue ; if ( XLog Rec Ptr Is Invalid ( walsnd - > flush ) ) continue ; if ( this priority = = 1 ) { result = lappend int ( result , i ) ; if ( am sync ! = NULL & & walsnd = = t thrd . walsender cxt . My Wal Snd ) * am sync = true ; if ( list length ( result ) = = t thrd . syncrep cxt . Sync Rep Config - > num sync ) { list free ( pending ) ; return result ; } } else { pending = lappend int ( pending , i ) ; if ( am sync ! = NULL & & walsnd = = t thrd . walsender cxt . My Wal Snd ) am in pending = true ; if ( this priority < next highest priority ) next highest priority = this priority ; } } if ( list length ( result ) + list length ( pending ) < = t thrd . syncrep cxt . Sync Rep Config - > num sync ) { bool needfree = ( result ! = NIL & & pending ! = NIL ) ; if ( am sync ! = NULL & & ! ( * am sync ) ) * am sync = am in pending ; result = list concat ( result , pending ) ; if ( needfree ) { pfree ( pending ) ; pending = NULL ; } return result ; } priority = next highest priority ; while ( priority < = lowest priority ) { List Cell * cell = NULL ; List Cell * prev = NULL ; List Cell * next = NULL ; next highest priority = lowest priority + 1 ; for ( cell = list head ( pending ) ; cell ! = NULL ; cell = next ) { i = lfirst int ( cell ) ; walsnd = & t thrd . walsender cxt . Wal Snd Ctl - > walsnds [ i ] ; next = lnext ( cell ) ; this priority = walsnd - > sync standby priority ; if ( this priority = = priority ) { result = lappend int ( result , i ) ; if ( am sync ! = NULL & & walsnd = = t thrd . walsender cxt . My Wal Snd ) * am sync = true ; if ( list length ( result ) = = t thrd . syncrep cxt . Sync Rep Config - > num sync ) { list free ( pending ) ; return result ; } pending = list delete cell ( pending , cell , prev ) ; continue ; } if ( this priority < next highest priority ) next highest priority = this priority ; prev = cell ; } priority = next highest priority ; } Assert ( false ) ; return result ; }", "predictions": ["this static"], "references": ["according to the priority, see if it can be connected. if the priority is the same, take the first."], "bleu": 0.00013000471131158705, "rouge_l": 0.0}
{"id": 63, "code": "static void Data Snd Check Time Out ( Timestamp Tz now ) { Timestamp Tz timeout ; if ( t thrd . datasender cxt . last reply timestamp < = 0 ) return ; timeout = Timestamp Tz Plus Milliseconds ( t thrd . datasender cxt . last reply timestamp , u sess - > attr . attr storage . wal sender timeout ) ; if ( u sess - > attr . attr storage . wal sender timeout > 0 & & now > = timeout ) { ereport ( COMMERROR , ( errmsg ( \" terminating Datasender process due to replication timeout \" ) ) ) ; Data Snd Shutdown ( ) ; } }", "predictions": ["this method"], "references": ["check that the time since the last standby received message has reached the configured limit."], "bleu": 0.0009606121050066008, "rouge_l": 0.0}
{"id": 64, "code": "XLog Seg No Wal Get Sync Count Window ( void ) { return ( XLog Seg No ) ( uint32 ) u sess - > attr . attr storage . wal keep segments ; }", "predictions": ["function function:"], "references": ["get the count pane of wal synchronously"], "bleu": 0.0524476438328049, "rouge_l": 0.0}
{"id": 65, "code": "static void Data Rcv Stream Send ( const char * buffer , int nbytes ) { if ( PQput Copy Data ( t thrd . datareceiver cxt . data Streaming Conn , buffer , nbytes ) < = 0 | | PQflush ( t thrd . datareceiver cxt . data Streaming Conn ) ) { ereport ( ERROR , ( errcode ( ERRCODE INVALID STATUS ) , errmsg ( \" could not send data to DATA stream : % s \" , PQerror Message ( t thrd . datareceiver cxt . data Streaming Conn ) ) ) ) ; } }", "predictions": ["get data"], "references": ["send a message to the data stream. report errors."], "bleu": 0.022945049537581412, "rouge_l": 0.16310160427807485}
{"id": 66, "code": "static Data Base Dir State Check Database Ready ( Oid spc Node , Oid db Node ) { char * dbpath = NULL ; struct stat st ; int n Ret = 0 ; Data Base Dir State db Dir State = NONEEXISTDATABASEDIR ; dbpath = Get Database Path ( db Node , spc Node ) ; pg memory barrier ( ) ; Assert ( Oid Is Valid ( spc Node ) ) ; retry : if ( stat ( dbpath , & st ) < 0 ) { pg memory barrier ( ) ; if ( t thrd . xlog cxt . Redo Done ) { db Dir State = NONEEXISTDATABASEDIR ; ereport ( LOG , ( errmsg ( \" skip the dropped database directory \" ) ) ) ; return db Dir State ; } if ( errno = = ENOENT ) { # if defined ( HAVE READLINK ) | | defined ( WIN32 ) char tbpath [ 64 ] = { 0 } ; char linkpath [ MAXPGPATH ] = { 0 } ; int rllen = 0 ; if ( spc Node = = GLOBALTABLESPACE OID | | spc Node = = DEFAULTTABLESPACE OID ) goto invalid handle ; n Ret = snprintf s ( tbpath , sizeof ( tbpath ) , 63 , \" pg tblspc / % u \" , spc Node ) ; securec check ss ( n Ret , \" \" , \" \" ) ; rllen = readlink ( tbpath , linkpath , sizeof ( linkpath ) ) ; if ( rllen < 0 ) { if ( errno = = EINVAL | | errno = = ENOTDIR ) { pfree ( dbpath ) ; dbpath = NULL ; ereport ( PANIC , ( errmsg ( \" could not read symbolic link \\ \" % s \\ \" : % m \" , tbpath ) ) ) ; } else if ( errno = = ENOENT ) { ereport ( DEBUG3 , ( errmsg ( \" sleep a while waiting for tablespace \\ \" % s \\ \" ready \" , tbpath ) ) ) ; goto invalid handle ; } else { pfree ( dbpath ) ; dbpath = NULL ; ereport ( ERROR , ( errcode for file access ( ) , errmsg ( \" invalid tablespace link % s : % m \" , tbpath ) ) ) ; } } else if ( rllen > = ( int ) sizeof ( linkpath ) ) { pfree ( dbpath ) ; dbpath = NULL ; ereport ( ERROR , ( errcode ( ERRCODE WRONG OBJECT TYPE ) , errmsg ( \" symbolic link \\ \" % s \\ \" target is too long \" , tbpath ) ) ) ; } else { linkpath [ rllen ] = ' \\ 0 ' ; if ( stat ( linkpath , & st ) < 0 | | ! S ISDIR ( st . st mode ) ) ereport ( PANIC , ( errcode ( ERRCODE WRONG OBJECT TYPE ) , errmsg ( \" invalid tablespace directory % s : % m \" , tbpath ) ) ) ; goto invalid handle ; } # else pfree ( dbpath ) ; dbpath = NULL ; ereport ( ERROR , ( errcode ( ERRCODE FEATURE NOT SUPPORTED ) , errmsg ( \" tablespaces are not supported on this platform \" ) ) ) ; # endif } else { pfree ( dbpath ) ; dbpath = NULL ; ereport ( ERROR , ( errcode ( ERRCODE WRONG OBJECT TYPE ) , errmsg ( \" \\ \" database % u / % u \\ \" invalid directory : % m \" , spc Node , db Node ) ) ) ; } } else { pfree ( dbpath ) ; dbpath = NULL ; if ( ! S ISDIR ( st . st mode ) ) ereport ( ERROR , ( errcode ( ERRCODE WRONG OBJECT TYPE ) , errmsg ( \" \\ \" database % u / % u \\ \" exists but is not a directory \" , spc Node , db Node ) ) ) ; db Dir State = EXISTDATABASEDIR ; return db Dir State ; } invalid handle : if ( ( t thrd . int cxt . Proc Die Pending | | t thrd . proc cxt . proc exit inprogress ) & & ! t thrd . datarcvwriter cxt . Am Data Receiver For Dummy Standby ) { ereport ( WARNING , ( errcode ( ERRCODE ADMIN SHUTDOWN ) , errmsg ( \" canceling the wait for database directory \\ \" % s \\ \" \" \" being created in recovery \" , dbpath ) ) ) ; pfree ( dbpath ) ; dbpath = NULL ; db Dir State = DATABASEDIRCREATECANCEL ; return db Dir State ; } ereport ( LOG , ( errmsg ( \" waiting for database directory \\ \" % s \\ \" being created in recovery \" , dbpath ) ) ) ; pg usleep ( 5000000 L ) ; goto retry ; }", "predictions": ["get the implement implement implement"], "references": ["check whether the database exists"], "bleu": 0.2730120862709067, "rouge_l": 0.2}
{"id": 67, "code": "static void bcm read multi cu ( CUFile * c File , Relation rel , int col , Block Number heap Block , int & contibits , Block Number max Heap Block ) { uint64 offset = ALIGNOF CUSIZE * ( uint64 ) heap Block ; char * write buf = NULL ; int real Size = 0 ; if ( u sess - > attr . attr storage . Ha Module Debug ) { ereport ( LOG , ( errmsg ( \" HA - bcm read multi cu : relation % u / % u / % u col % d try to sync \" \" cu blockno % u , contibits % d , max Heap Block % u \" , rel - > rd node . spc Node , rel - > rd node . db Node , rel - > rd node . rel Node , col , heap Block , contibits , max Heap Block ) ) ) ; } if ( heap Block > max Heap Block ) { contibits = 0 ; return ; } contibits = ( int ) Min ( ( uint32 ) contibits , max Heap Block - heap Block + 1 ) ; while ( contibits > 0 ) { Catchup Shutdown If No Data Sender ( ) ; write buf = c File - > Read ( offset , ALIGNOF CUSIZE * contibits , & real Size ) ; if ( write buf = = NULL ) { Assert ( real Size = = 0 ) ; contibits = 0 ; return ; } if ( u sess - > attr . attr storage . Ha Module Debug ) check cu block ( write buf , real Size ) ; PushCUTo Data Queue ( rel , col , write buf , offset , real Size , false ) ; ereport ( DEBUG3 , ( errmsg ( \" cu Block % u col % d read and send data ' s realsize is % d . \" , heap Block , col , real Size ) ) ) ; offset + = real Size ; contibits - = real Size / ALIGNOF CUSIZE ; } Assert ( contibits = = 0 ) ; }", "predictions": ["function function:"], "references": ["load multiple cu units for buffering, and push the data to the sender queue."], "bleu": 0.0015837816104164078, "rouge_l": 0.0}
{"id": 68, "code": "static void wal Rcv Ctl Block Init ( ) { char * buf = NULL ; int64 rec Buffer Size = g instance . attr . attr storage . Wal Receiver Buf Size * 1024 ; size t len = offsetof ( Wal Rcv Ctl Block , wal Receiver Buffer ) + rec Buffer Size ; errno t rc = 0 ; Assert ( t thrd . walreceiver cxt . wal Rcv Ctl Block = = NULL ) ; buf = ( char * ) Memory Context Alloc ( t thrd . top mem cxt , len ) ; if ( buf = = NULL ) { ereport ( FATAL , ( errcode ( ERRCODE OUT OF MEMORY ) , errmsg ( \" out of memory \" ) ) ) ; } rc = memset s ( buf , sizeof ( Wal Rcv Ctl Block ) , 0 , sizeof ( Wal Rcv Ctl Block ) ) ; securec check c ( rc , \" \\ 0 \" , \" \\ 0 \" ) ; t thrd . walreceiver cxt . wal Rcv Ctl Block = ( Wal Rcv Ctl Block * ) buf ; Spin Lock Init ( & t thrd . walreceiver cxt . wal Rcv Ctl Block - > mutex ) ; }", "predictions": ["this function is used to Ctl"], "references": ["the wallrcv control block is initialized."], "bleu": 0.22089591134157885, "rouge_l": 0.16666666666666666}
{"id": 69, "code": "static bool Wal Snd DummyLEStandby ( void ) { XLog Rec Ptr flush Dummy = InvalidXLog Rec Ptr ; XLog Rec Ptr flush Standby = InvalidXLog Rec Ptr ; int i ; for ( i = 0 ; i < g instance . attr . attr storage . max wal senders ; i + + ) { volatile Wal Snd * walsnd = & t thrd . walsender cxt . Wal Snd Ctl - > walsnds [ i ] ; Spin Lock Acquire ( & walsnd - > mutex ) ; if ( walsnd - > pid ! = 0 & & walsnd - > send Role = = SNDROLE PRIMARY STANDBY ) { flush Standby = walsnd - > flush ; } else if ( walsnd - > pid ! = 0 & & walsnd - > send Role = = SNDROLE PRIMARY DUMMYSTANDBY ) { flush Dummy = walsnd - > flush ; } Spin Lock Release ( & walsnd - > mutex ) ; } if ( XLByteEQ ( flush Dummy , InvalidXLog Rec Ptr ) | | XLByteEQ ( flush Standby , InvalidXLog Rec Ptr ) ) return true ; return XLByteLE ( flush Dummy , flush Standby ) ; }", "predictions": ["this static"], "references": ["if the standby system has more xlogs than the virtual standby system, it returns true"], "bleu": 0.0009606121050066008, "rouge_l": 0.0}
{"id": 70, "code": "void heartbeat shmem init ( void ) { bool found = false ; t thrd . heartbeat cxt . state = ( heartbeat state * ) Shmem Init Struct ( \" heatbeat Shmem Data \" , heartbeat shmem size ( ) , & found ) ; if ( ! found ) { errno t rc = memset s ( t thrd . heartbeat cxt . state , heartbeat shmem size ( ) , 0 , heartbeat shmem size ( ) ) ; securec check ( rc , \" \" , \" \" ) ; Spin Lock Init ( & t thrd . heartbeat cxt . state - > mutex ) ; } }", "predictions": ["this function is used to heartbeat"], "references": ["allocates and initializes heartbeat shared memory functions"], "bleu": 0.1869843520537038, "rouge_l": 0.1517412935323383}
{"id": 71, "code": "static void Data Snd Handshake ( void ) { String Info Data input message ; bool replication started = false ; int sleep time = 0 ; init String Info ( & input message ) ; while ( ! replication started ) { int first char ; Data Snd Set State ( DATASNDSTATE STARTUP ) ; set ps display ( \" idle \" , false ) ; if ( ! pq select ( NAPTIME PER CYCLE ) ) { sleep time + = NAPTIME PER CYCLE ; if ( u sess - > attr . attr storage . wal sender timeout > 0 & & sleep time > = u sess - > attr . attr storage . wal sender timeout ) { ereport ( COMMERROR , ( errcode ( ERRCODE PROTOCOL VIOLATION ) , errmsg ( \" no message received from standby for maximum time \" ) ) ) ; proc exit ( 0 ) ; } continue ; } sleep time = 0 ; first char = pq getbyte ( ) ; if ( ! Postmaster Is Alive ( ) ) { gs thread exit ( 1 ) ; } if ( t thrd . datasender cxt . got SIGHUP ) { t thrd . datasender cxt . got SIGHUP = false ; Process Config File ( PGC SIGHUP ) ; } if ( first char ! = EOF ) { if ( pq getmessage ( & input message , 0 ) ) { first char = EOF ; } } switch ( first char ) { case ' Q ' : { const char * query string = NULL ; query string = pq getmsgstring ( & input message ) ; pq getmsgend ( & input message ) ; if ( Handle Data Replication Command ( query string ) ) { replication started = true ; } } break ; case ' X ' : proc exit ( 0 ) ; break ; case EOF : ereport ( COMMERROR , ( errcode ( ERRCODE PROTOCOL VIOLATION ) , errmsg ( \" unexpected EOF on standby connection \" ) ) ) ; proc exit ( 0 ) ; break ; default : ereport ( FATAL , ( errcode ( ERRCODE PROTOCOL VIOLATION ) , errmsg ( \" invalid standby handshake message type % d \" , first char ) ) ) ; } } }", "predictions": ["this function is used to get"], "references": ["command from data reception executed before entering stream mode."], "bleu": 0.1126634218241493, "rouge_l": 0.0}
{"id": 72, "code": "static void Process Heartbeat Packet Client ( int epoll Fd , int events , void * arg , void * * released Conn Ptr ) { ereport ( DEBUG2 , ( errmsg ( \" [ client ] process heartbeat . \" ) ) ) ; * released Conn Ptr = NULL ; Heartbeat Connection * con = ( Heartbeat Connection * ) arg ; Heartbeat Packet in Packet ; if ( pq getbytes ( con - > port , ( char * ) ( & in Packet ) , sizeof ( Heartbeat Packet ) ) ! = 0 ) { ereport ( LOG , ( errmsg ( \" connection closed by peer , disconnect . \" ) ) ) ; Heartbeat Client * client = ( Heartbeat Client * ) con - > arg ; client - > Dis Connect ( ) ; * released Conn Ptr = con ; return ; } con - > last Active Time = Get Current Timestamp ( ) ; Update Last Heartbeat Time ( con - > remote Host , con - > channel Identifier , con - > last Active Time ) ; }", "predictions": ["this function is used to obtain"], "references": ["create connection function between client and database"], "bleu": 0.1869843520537038, "rouge_l": 0.1517412935323383}
{"id": 73, "code": "static void Wal Snd Last Cycle Handler ( SIGNAL ARGS ) { int save errno = errno ; t thrd . walsender cxt . walsender ready to stop = true ; if ( t thrd . walsender cxt . My Wal Snd ) Set Latch ( & t thrd . walsender cxt . My Wal Snd - > latch ) ; if ( IS DN DUMMY STANDYS MODE ( ) ) { if ( t thrd . walsender cxt . My Wal Snd & & ! Am Wal Sender To Dummy Standby ( ) & & ( t thrd . walsender cxt . My Wal Snd - > node state = = NODESTATE PROMOTE APPROVE | | t thrd . walsender cxt . My Wal Snd - > node state = = NODESTATE STANDBY REDIRECT ) ) t thrd . walsender cxt . response switchover requested = true ; } else { if ( t thrd . walsender cxt . My Wal Snd & & t thrd . walsender cxt . My Wal Snd - > node state = = NODESTATE PROMOTE APPROVE ) t thrd . walsender cxt . response switchover requested = true ; } errno = save errno ; }", "predictions": ["this method"], "references": ["set the flag for the last loop, then close"], "bleu": 0.019294409903971108, "rouge_l": 0.0}
{"id": 74, "code": "static void empty Wal Rcv Writer Latch ( void ) { volatile Wal Rcv Data * walrcv = t thrd . walreceiverfuncs cxt . Wal Rcv ; Spin Lock Acquire ( & walrcv - > mutex ) ; walrcv - > walrcv Writer Latch = NULL ; walrcv - > writer Pid = 0 ; Spin Lock Release ( & walrcv - > mutex ) ; }", "predictions": ["empty empty"], "references": ["clear the latch of the wallcvwriter."], "bleu": 0.08647154598524984, "rouge_l": 0.0}
{"id": 75, "code": "static int Sync Rep Get Standby Priority ( void ) { const char * standby name = NULL ; int priority ; bool found = false ; if ( AM WAL STANDBY SENDER ) return 0 ; if ( ! Sync Standbys Defined ( ) | | t thrd . syncrep cxt . Sync Rep Config = = NULL | | ! Sync Rep Requested ( ) ) return 0 ; standby name = t thrd . syncrep cxt . Sync Rep Config - > member names ; for ( priority = 1 ; priority < = t thrd . syncrep cxt . Sync Rep Config - > nmembers ; priority + + ) { if ( pg strcasecmp ( standby name , u sess - > attr . attr common . application name ) = = 0 | | strcmp ( standby name , \" * \" ) = = 0 ) { found = true ; break ; } standby name + = strlen ( standby name ) + 1 ; } if ( ! found ) { return 0 ; } return ( t thrd . syncrep cxt . Sync Rep Config - > syncrep method = = SYNC REP PRIORITY ) ? priority : 1 ; }", "predictions": ["function function: < br / >"], "references": ["the synchronization representative gets the standby priority"], "bleu": 0.15723447135049806, "rouge_l": 0.0}
{"id": 76, "code": "static bool Data Snd Caughtup ( void ) { int i ; for ( i = 0 ; i < g instance . attr . attr storage . max wal senders ; i + + ) { volatile Data Snd * datasnd = & t thrd . datasender cxt . Data Snd Ctl - > datasnds [ i ] ; Spin Lock Acquire ( & datasnd - > mutex ) ; if ( datasnd - > pid ! = 0 & & datasnd - > send Role = = SNDROLE PRIMARY STANDBY & & datasnd - > state = = DATASNDSTATE STREAMING ) { Spin Lock Release ( & datasnd - > mutex ) ; return true ; } Spin Lock Release ( & datasnd - > mutex ) ; } return false ; }", "predictions": ["this function is used to be"], "references": ["returns true if any standby (except virtual standby) information is captured"], "bleu": 0.09600096733558854, "rouge_l": 0.1117216117216117}
{"id": 77, "code": "List * Sync Rep Get Sync Standbys ( bool * am sync ) { if ( am sync ! = NULL ) * am sync = false ; if ( t thrd . syncrep cxt . Sync Rep Config = = NULL ) return NIL ; return ( t thrd . syncrep cxt . Sync Rep Config - > syncrep method = = SYNC REP PRIORITY ) ? Sync Rep Get Sync Standbys Priority ( am sync ) : Sync Rep Get Sync Standbys Quorum ( am sync ) ; }", "predictions": ["this function is used to the"], "references": ["synchronous replication get synchronous standby. < br / > standby: standby machine, a node in opengauss dual machine scheme, is used as the backup of the host. when the host is abnormal, the standby machine switches to the host state to ensure the normal data service."], "bleu": 0.00046521793286095876, "rouge_l": 0.13510520487264674}
{"id": 78, "code": "static void Data Rcv Process Msg ( unsigned char type , char * buf , Size len ) { errno t errorno = EOK ; switch ( type ) { case ' b ' : { if ( dummy Standby Mode ) { ereport ( LOG , ( errmsg ( \" Received incremental searching bcm message \" ) ) ) ; Parse Dummy File ( ) ; break ; } } / / lint - fallthrough case ' d ' : { Data Page Message Header msghdr ; if ( len < sizeof ( Data Page Message Header ) ) ereport ( ERROR , ( errcode ( ERRCODE PROTOCOL VIOLATION ) , errmsg internal ( \" invalid data page message received from primary \" ) ) ) ; errorno = memcpy s ( & msghdr , sizeof ( Data Page Message Header ) , buf , sizeof ( Data Page Message Header ) ) ; securec check ( errorno , \" \" , \" \" ) ; Process Data Header Message ( & msghdr ) ; buf + = sizeof ( Data Page Message Header ) ; len - = sizeof ( Data Page Message Header ) ; volatile Data Rcv Data * datarcv = t thrd . datareceiver cxt . Data Rcv ; if ( datarcv - > conn target ! = REPCONNTARGET DUMMYSTANDBY ) { DQByte Advance ( msghdr . data Start , len ) ; if ( ! DQByteEQ ( msghdr . data Start , msghdr . data End ) ) ereport ( PANIC , ( errcode ( ERRCODE PROTOCOL VIOLATION ) , errmsg ( \" invalid message header , maybe the parameter of \" \" \\ \" data replicate buffer size \\ \" on the master has been changed \" ) , errhint ( \" You might need to restart the instance . \" ) ) ) ; } else if ( unlikely ( ! Data Queue Ptr Is Invalid ( msghdr . data End ) ) ) { ereport ( PANIC , ( errcode ( ERRCODE PROTOCOL VIOLATION ) , errmsg ( \" invalid message end \" ) ) ) ; } Data Rcv Receive ( buf , len ) ; break ; } case ' k ' : { Data Snd Keepalive Message keepalive ; if ( len ! = sizeof ( Data Snd Keepalive Message ) ) ereport ( ERROR , ( errcode ( ERRCODE PROTOCOL VIOLATION ) , errmsg internal ( \" invalid keepalive message received from primary \" ) ) ) ; errorno = memcpy s ( & keepalive , sizeof ( Data Snd Keepalive Message ) , buf , sizeof ( Data Snd Keepalive Message ) ) ; securec check ( errorno , \" \" , \" \" ) ; Process Keepalive Message ( & keepalive ) ; if ( keepalive . reply Requested ) Data Rcv Send Reply ( true , false ) ; break ; } case ' e ' : { End Data Message end Data Message ; if ( len ! = sizeof ( End Data Message ) ) ereport ( ERROR , ( errcode ( ERRCODE PROTOCOL VIOLATION ) , errmsg internal ( \" invalid End Data Message message received from Secondary Standby \" ) ) ) ; errorno = memcpy s ( & end Data Message , sizeof ( End Data Message ) , buf , sizeof ( End Data Message ) ) ; securec check ( errorno , \" \" , \" \" ) ; Process End Data Message ( & end Data Message ) ; break ; } case ' x ' : { Rm Data Message rm Data Message ; if ( len ! = sizeof ( Rm Data Message ) ) ereport ( ERROR , ( errcode ( ERRCODE PROTOCOL VIOLATION ) , errmsg internal ( \" invalid Rm Data message received from primary \" ) ) ) ; errorno = memcpy s ( & rm Data Message , sizeof ( Rm Data Message ) , buf , sizeof ( Rm Data Message ) ) ; securec check ( errorno , \" \" , \" \" ) ; Process Rm Data Message ( & rm Data Message ) ; break ; } default : ereport ( ERROR , ( errcode ( ERRCODE PROTOCOL VIOLATION ) , errmsg internal ( \" invalid data replication message type % d \" , type ) ) ) ; } }", "predictions": ["get the input"], "references": ["this function is used to process the received data according to the classification of data!"], "bleu": 0.00984071741598585, "rouge_l": 0.0991869918699187}
{"id": 79, "code": "static void Wal Data Rcv Receive ( char * buf , Size nbytes , XLog Rec Ptr recptr ) { uint32 expected len = 0 ; # ifdef DATA DEBUG pg crc32 crc ; # endif Size left len = nbytes ; char * cur buf = buf ; errno t errorno = EOK ; char data flag = 0 ; XLog Rec Ptr received ptr = InvalidXLog Rec Ptr ; bool empty streaming body = false ; while ( left len > 0 ) { errorno = memcpy s ( & expected len , sizeof ( uint32 ) , cur buf , sizeof ( uint32 ) ) ; securec check ( errorno , \" \\ 0 \" , \" \\ 0 \" ) ; cur buf + = sizeof ( uint32 ) ; data flag = cur buf [ 0 ] ; Assert ( data flag = = ' d ' | | data flag = = ' w ' ) ; cur buf + = 1 ; if ( data flag = = ' d ' ) { if ( expected len < = ( sizeof ( uint32 ) + 1 + sizeof ( XLog Rec Ptr ) * 2 ) ) { Assert ( false ) ; ereport ( ERROR , ( errcode ( ERRCODE INVALID PARAMETER VALUE ) , errmsg ( \" the received wal data is unexpected % u bytes at least more than % lu bytes \" , expected len , ( sizeof ( uint32 ) + 1 + sizeof ( XLog Rec Ptr ) * 2 ) ) ) ) ; } } else if ( data flag = = ' w ' ) { if ( expected len < ( sizeof ( uint32 ) + 1 + sizeof ( XLog Rec Ptr ) ) ) { Assert ( false ) ; ereport ( ERROR , ( errcode ( ERRCODE INVALID PARAMETER VALUE ) , errmsg ( \" the received xlog is unexpected % u bytes at least more than % lu bytes . \" , expected len , ( sizeof ( uint32 ) + 1 + sizeof ( XLog Rec Ptr ) ) ) ) ) ; } errorno = memcpy s ( & received ptr , sizeof ( XLog Rec Ptr ) , cur buf , sizeof ( XLog Rec Ptr ) ) ; securec check ( errorno , \" \\ 0 \" , \" \\ 0 \" ) ; if ( expected len = = ( sizeof ( uint32 ) + 1 + sizeof ( XLog Rec Ptr ) ) ) { ereport ( DEBUG2 , ( errmsg ( \" received empty streaming body at % X / % X . \" , ( uint32 ) ( received ptr > > 32 ) , ( uint32 ) received ptr ) ) ) ; empty streaming body = true ; } if ( ! empty streaming body ) { XLByte Advance ( recptr , ( uint32 ) ( expected len - WAL DATA LEN ) ) ; Spin Lock Acquire ( & t thrd . walreceiver cxt . wal Rcv Ctl Block - > mutex ) ; t thrd . walreceiver cxt . wal Rcv Ctl Block - > receive Ptr = recptr ; Spin Lock Release ( & t thrd . walreceiver cxt . wal Rcv Ctl Block - > mutex ) ; } } else { Assert ( false ) ; ereport ( ERROR , ( errcode ( ERRCODE INVALID PARAMETER VALUE ) , errmsg ( \" fail to push some wal data to the wal streaming writer queue : unexpected wal data flag % c . \" , data flag ) ) ) ; } if ( ! empty streaming body ) { ( void ) Push To Writer Queue ( cur buf - sizeof ( uint32 ) - 1 , expected len ) ; ereport ( DEBUG5 , ( errmsg ( \" push some wal data to the wal streaming writer queue : data flag % c , % u bytes . \" , data flag , expected len ) ) ) ; } else empty streaming body = false ; cur buf + = ( expected len - ( sizeof ( uint32 ) + 1 ) ) ; left len - = expected len ; wakeup Wal Rcv Writer ( ) ; } Assert ( left len = = 0 ) ; wakeup Wal Rcv Writer ( ) ; }", "predictions": ["function function: < br / >"], "references": ["there are two types of receiving data: replication data and xlog."], "bleu": 0.08072686929338534, "rouge_l": 0.0}
{"id": 80, "code": "bool Wal Rcv In Progress ( void ) { volatile Wal Rcv Data * walrcv = t thrd . walreceiverfuncs cxt . Wal Rcv ; Wal Rcv State state ; pg time t start Time ; Spin Lock Acquire ( & walrcv - > mutex ) ; state = walrcv - > wal Rcv State ; start Time = walrcv - > start Time ; Spin Lock Release ( & walrcv - > mutex ) ; if ( state = = WALRCV STARTING ) { pg time t now = ( pg time t ) time ( NULL ) ; if ( ( now - start Time ) > WALRCV STARTUP TIMEOUT ) { Spin Lock Acquire ( & walrcv - > mutex ) ; if ( walrcv - > wal Rcv State = = WALRCV STARTING ) state = walrcv - > wal Rcv State = WALRCV STOPPED ; Spin Lock Release ( & walrcv - > mutex ) ; ereport ( WARNING , ( errmsg ( \" shut down walreceiver due to start up timeout , \" \" timeout = % d , now = % ld , starttime = % ld \" , WALRCV STARTUP TIMEOUT , now , start Time ) ) ) ; } } if ( state ! = WALRCV STOPPED ) return true ; else return false ; }", "predictions": ["this function is used to obtain"], "references": ["check that walreceiver is running."], "bleu": 0.22089591134157885, "rouge_l": 0.18484848484848485}
{"id": 81, "code": "static void Data Snd Last Cycle Handler ( SIGNAL ARGS ) { int save errno = errno ; t thrd . datasender cxt . datasender ready to stop = true ; if ( t thrd . datasender cxt . My Data Snd ) Set Latch ( & t thrd . datasender cxt . My Data Snd - > latch ) ; errno = save errno ; }", "predictions": ["this function is used to save"], "references": ["exit after the last loop and set a flag"], "bleu": 0.1126634218241493, "rouge_l": 0.0}
{"id": 82, "code": "void Shutdown Wal Rcv ( void ) { volatile Wal Rcv Data * walrcv = t thrd . walreceiverfuncs cxt . Wal Rcv ; Thread Id walrcvpid = 0 ; int i = 1 ; const int COUNTS = 2000 ; Spin Lock Acquire ( & walrcv - > mutex ) ; switch ( walrcv - > wal Rcv State ) { case WALRCV STOPPED : break ; case WALRCV STARTING : walrcv - > wal Rcv State = WALRCV STOPPED ; break ; case WALRCV RUNNING : walrcv - > wal Rcv State = WALRCV STOPPING ; / / lint - fallthrough case WALRCV STOPPING : walrcvpid = walrcv - > pid ; break ; } Spin Lock Release ( & walrcv - > mutex ) ; ereport ( LOG , ( errmsg ( \" startup shut down walreceiver . \" ) ) ) ; if ( walrcvpid ! = 0 ) ( void ) gs signal send ( walrcvpid , SIGTERM ) ; while ( Wal Rcv In Progress ( ) ) { Handle Startup Proc Interrupts ( ) ; pg usleep ( 100000 ) ; Spin Lock Acquire ( & walrcv - > mutex ) ; walrcvpid = walrcv - > pid ; Spin Lock Release ( & walrcv - > mutex ) ; if ( ( walrcvpid ! = 0 ) & & ( i % COUNTS = = 0 ) ) { ( void ) gs signal send ( walrcvpid , SIGTERM ) ; i = 1 ; } i + + ; } }", "predictions": ["this function is used to"], "references": ["kill the walrcv process, which can be called when walreceiver is running normally or waiting."], "bleu": 0.0369481680224917, "rouge_l": 0.09172932330827067}
{"id": 83, "code": "static bool Handle Data Replication Command ( const char * cmd string ) { bool replication started = false ; int parse rc ; Node * cmd node = NULL ; Memory Context cmd context ; Memory Context old context ; replication scanner yyscan t yyscanner = NULL ; ereport ( LOG , ( errmsg ( \" received data replication command : % s \" , cmd string ) ) ) ; cmd context = Alloc Set Context Create ( Current Memory Context , \" Replication command context \" , ALLOCSET DEFAULT MINSIZE , ALLOCSET DEFAULT INITSIZE , ALLOCSET DEFAULT MAXSIZE ) ; yyscanner = replication scanner init ( cmd string ) ; parse rc = replication yyparse ( yyscanner ) ; replication scanner finish ( yyscanner ) ; if ( parse rc ! = 0 ) { ereport ( ERROR , ( errcode ( ERRCODE SYNTAX ERROR ) , ( errmsg internal ( \" replication command parser returned % d \" , parse rc ) ) ) ) ; } old context = Memory Context Switch To ( cmd context ) ; cmd node = t thrd . replgram cxt . replication parse result ; switch ( cmd node - > type ) { case T Identify System Cmd : Identify System ( ) ; break ; case T Identify Mode Cmd : Identify Mode ( ) ; break ; case T Start Data Replication Cmd : Start Data Replication ( ( Start Data Replication Cmd * ) cmd node ) ; replication started = true ; break ; default : ereport ( FATAL , ( errcode ( ERRCODE PROTOCOL VIOLATION ) , errmsg ( \" invalid standby query string : % s \" , cmd string ) ) ) ; } Memory Context Switch To ( old context ) ; Memory Context Delete ( cmd context ) ; return replication started ; }", "predictions": ["function function: < br / >"], "references": ["execute the incoming data replication command."], "bleu": 0.18575057999133598, "rouge_l": 0.0}
{"id": 84, "code": "int logical read local xlog page ( XLog Reader State * state , XLog Rec Ptr target Page Ptr , int req Len , XLog Rec Ptr target Rec Ptr , char * cur page , Time LineID * pageTLI ) { XLog Rec Ptr flushptr , loc ; int count ; loc = target Page Ptr + req Len ; while ( 1 ) { if ( ! Recovery In Progress ( ) ) { * pageTLI = t thrd . xlog cxt . This Time LineID ; flushptr = Get Flush Rec Ptr ( ) ; } else flushptr = GetXLog Replay Rec Ptr ( pageTLI ) ; if ( XLByteLE ( loc , flushptr ) ) break ; CHECK FOR INTERRUPTS ( ) ; pg usleep ( 1000 L ) ; } if ( ( target Page Ptr ) + XLOG BLCKSZ < = ( flushptr ) ) count = XLOG BLCKSZ ; else if ( ( target Page Ptr ) + req Len > ( flushptr ) ) return - 1 ; else count = ( flushptr ) - ( target Page Ptr ) ; XLog Read ( cur page , * pageTLI , target Page Ptr , XLOG BLCKSZ ) ; return count ; }", "predictions": ["this function is used to obtain obtain"], "references": ["gets the number of logically readable pages of the client file"], "bleu": 0.08820727472213225, "rouge_l": 0.0}
{"id": 85, "code": "bool check abs tblspac path ( const char * fname , int * seg No ) { char buf [ FILE NAME MAX LEN ] = { 0 } ; Rel File Node rnode ; int columnid = 0 ; int nmatch ; rnode . spc Node = Invalid Oid ; rnode . db Node = Invalid Oid ; rnode . rel Node = Invalid Oid ; nmatch = sscanf s ( fname , \" PG 9 . 2 201611171 % [ ^ / ] / % u / % u C % d . % u \" , buf , sizeof ( buf ) , & rnode . db Node , & rnode . rel Node , & columnid , seg No ) ; if ( nmatch = = MATCH SIX ) { return false ; } nmatch = sscanf s ( fname , \" PG 9 . 2 201611171 % [ ^ / ] / % u / % u b % d . % u \" , buf , sizeof ( buf ) , & rnode . db Node , & rnode . rel Node , & rnode . bucket Node , seg No ) ; if ( nmatch = = MATCH FIVE | | nmatch = = MATCH SIX ) { return true ; } nmatch = sscanf s ( fname , \" PG 9 . 2 201611171 % [ ^ / ] / % u / % u b % d fsm . % u \" , buf , sizeof ( buf ) , & rnode . db Node , & rnode . rel Node , & rnode . bucket Node , seg No ) ; if ( nmatch = = MATCH FIVE | | nmatch = = MATCH SIX ) { return true ; } nmatch = sscanf s ( fname , \" PG 9 . 2 201611171 % [ ^ / ] / % u / % u b % d vm . % u \" , buf , sizeof ( buf ) , & rnode . db Node , & rnode . rel Node , & rnode . bucket Node , seg No ) ; if ( nmatch = = MATCH FIVE | | nmatch = = MATCH SIX ) { return true ; } nmatch = sscanf s ( fname , \" PG 9 . 2 201611171 % [ ^ / ] / % u / % u . % u \" , buf , sizeof ( buf ) , & rnode . db Node , & rnode . rel Node , seg No ) ; if ( nmatch = = MATCH FOUR | | nmatch = = MATCH FIVE ) { return true ; } nmatch = sscanf s ( fname , \" PG 9 . 2 201611171 % [ ^ / ] / % u / % u fsm . % u \" , buf , sizeof ( buf ) , & rnode . db Node , & rnode . rel Node , seg No ) ; if ( nmatch = = MATCH FOUR | | nmatch = = MATCH FIVE ) { return true ; } nmatch = sscanf s ( fname , \" PG 9 . 2 201611171 % [ ^ / ] / % u / % u vm . % u \" , buf , sizeof ( buf ) , & rnode . db Node , & rnode . rel Node , seg No ) ; if ( nmatch = = MATCH FOUR | | nmatch = = MATCH FIVE ) { return true ; } return false ; }", "predictions": ["this function is used to obtain obtain obtain obtain obtain obtain obtain obtain"], "references": ["check the absolute path of the incoming table space"], "bleu": 0.08032276872815308, "rouge_l": 0.0}
{"id": 86, "code": "static void heartbeat handle exception ( Memory Context heartbeat context ) { t thrd . log cxt . error context stack = NULL ; HOLD INTERRUPTS ( ) ; Emit Error Report ( ) ; Resource Owner Release ( t thrd . utils cxt . Current Resource Owner , RESOURCE RELEASE BEFORE LOCKS , false , true ) ; g instance . heartbeat cxt . heartbeat running = false ; destroy client and server ( ) ; ( void ) Memory Context Switch To ( heartbeat context ) ; Flush Error State ( ) ; Memory Context Reset And Delete Children ( heartbeat context ) ; RESUME INTERRUPTS ( ) ; pg usleep ( 1000000 L ) ; return ; }", "predictions": ["function function:"], "references": ["dealing with abnormal heartbeat"], "bleu": 0.23505403213046533, "rouge_l": 0.0}
{"id": 87, "code": "int Wal Sender Main ( void ) { Memory Context walsnd context ; int n Ret = 0 ; t thrd . proc cxt . My Prog Name = \" Wal Sender \" ; if ( Recovery In Progress ( ) ) { t thrd . role = WAL STANDBY SENDER ; } if ( g thread Pool Controler ) { ereport ( INFO , ( errmsg ( \" Try to bind walsender thread to available CPUs in threadpool . \" ) ) ) ; g thread Pool Controler - > Bind Thread To All Avail Cpu ( t thrd . proc cxt . My Proc Pid ) ; } Init Wal Snd ( ) ; ereport ( LOG , ( errmsg ( \" walsender thread started \" ) ) ) ; walsnd context = Alloc Set Context Create ( t thrd . top mem cxt , \" Wal Sender \" , ALLOCSET DEFAULT MINSIZE , ALLOCSET DEFAULT INITSIZE , ALLOCSET DEFAULT MAXSIZE ) ; ( void ) Memory Context Switch To ( walsnd context ) ; t thrd . utils cxt . Current Resource Owner = Resource Owner Create ( NULL , \" walsender top - level resource owner \" ) ; Mark Postmaster Child Wal Sender ( ) ; Send Postmaster Signal ( PMSIGNAL ADVANCE STATE MACHINE ) ; gs signal setmask ( & t thrd . libpq cxt . Un Block Sig , NULL ) ; if ( AM WAL STANDBY SENDER ) t thrd . xlog cxt . This Time LineID = Get Recovery TargetTLI ( ) ; if ( dummy Standby Mode ) { Shutdown Wal Rcv ( ) ; t thrd . xlog cxt . This Time LineID = Get Recovery TargetTLI ( ) ; t thrd . xlog cxt . recovery TargetTLI = Get Recovery TargetTLI ( ) ; ereport ( LOG , ( errmsg ( \" This Time LineID : % u \" , t thrd . xlog cxt . This Time LineID ) ) ) ; } Ready For Query noblock ( Dest Remote , u sess - > attr . attr storage . wal sender timeout ) ; if ( t thrd . postmaster cxt . Ha Shm Data ) t thrd . walsender cxt . server run mode = t thrd . postmaster cxt . Ha Shm Data - > current mode ; Set Ha Wal Sender Channel ( ) ; Wal Snd Handshake ( ) ; { volatile Wal Snd * walsnd = t thrd . walsender cxt . My Wal Snd ; Spin Lock Acquire ( & walsnd - > mutex ) ; walsnd - > pid = t thrd . proc cxt . My Proc Pid ; # ifndef WIN32 walsnd - > lwp Id = syscall ( SYS gettid ) ; # else walsnd - > lwp Id = ( int ) t thrd . proc cxt . My Proc Pid # endif if ( AM WAL DB SENDER ) { walsnd - > sent Ptr = t thrd . slot cxt . My Replication Slot - > data . restart lsn ; } else { walsnd - > sent Ptr = t thrd . walsender cxt . sent Ptr ; } Spin Lock Release ( & walsnd - > mutex ) ; if ( walsnd - > send Role = = SNDROLE PRIMARY DUMMYSTANDBY ) { pgstat report appname ( \" Wal Sender to Secondary \" ) ; } else if ( walsnd - > send Role = = SNDROLE PRIMARY BUILDSTANDBY ) { pgstat report appname ( \" Wal Sender to Build \" ) ; } else if ( walsnd - > send Role = = SNDROLE PRIMARY STANDBY ) { pgstat report appname ( \" Wal Sender to Standby \" ) ; } } Sync Rep Init Config ( ) ; if ( t thrd . proc cxt . Data Dir ) { n Ret = snprintf s ( t thrd . walsender cxt . gucconf file , MAXPGPATH , MAXPGPATH - 1 , \" % s / postgresql . conf \" , t thrd . proc cxt . Data Dir ) ; securec check ss ( n Ret , \" \\ 0 \" , \" \\ 0 \" ) ; n Ret = snprintf s ( t thrd . walsender cxt . gucconf lock file , MAXPGPATH , MAXPGPATH - 1 , \" % s / postgresql . conf . lock \" , t thrd . proc cxt . Data Dir ) ; securec check ss ( n Ret , \" \\ 0 \" , \" \\ 0 \" ) ; } else { ereport ( ERROR , ( errcode ( ERRCODE PROTOCOL VIOLATION ) , errmsg internal ( \" cannot find GAUSSDATA : % s \" , t thrd . walsender cxt . gucconf file ) ) ) ; } if ( g instance . attr . attr storage . enable mix replication & & dummy Standby Mode ) InitWSData Num On Dummy Standby ( ) ; if ( g instance . attr . attr storage . enable mix replication & & ! u sess - > attr . attr storage . enable cbm tracking ) ereport ( PANIC , ( errmsg ( \" enable cbm tracking must be turn on when enable mix replication is on ! \" ) ) ) ; if ( AM WAL DB SENDER ) return Wal Snd Loop ( XLog Send Logical ) ; else return Wal Snd Loop ( XLog Send Physical ) ; }", "predictions": ["this method"], "references": ["define entry point function"], "bleu": 0.23505403213046533, "rouge_l": 0.0}
{"id": 88, "code": "void Wal Snd Rqst File Reload ( void ) { int i ; for ( i = 0 ; i < g instance . attr . attr storage . max wal senders ; i + + ) { volatile Wal Snd * walsnd = & t thrd . walsender cxt . Wal Snd Ctl - > walsnds [ i ] ; if ( walsnd - > pid = = 0 ) continue ; Spin Lock Acquire ( & walsnd - > mutex ) ; walsnd - > needreload = true ; Spin Lock Release ( & walsnd - > mutex ) ; } }", "predictions": ["this method"], "references": ["this static method is used to request the wal log sender to reload the currently opened wal file"], "bleu": 0.0002820893212548129, "rouge_l": 0.17478510028653294}
{"id": 89, "code": "bool Data Snd In Searching ( void ) { return dummy Searching ; }", "predictions": ["Snd"], "references": ["this function determines whether the data is being sent, and returns the search result ture or false"], "bleu": 9.463042501137543e-08, "rouge_l": 0.0}
{"id": 90, "code": "static uint32 Data Send Read Data ( char * buf , uint32 bufsize ) { uint32 bytesread = 0 ; char path [ MAXPGPATH ] = { 0 } ; uint32 nbytes = 0 ; uint32 total len = 0 ; errno t rc = EOK ; int n Ret = 0 ; rc = memset s ( buf , bufsize , 0 , bufsize ) ; securec check ( rc , \" \" , \" \" ) ; retry : while ( t thrd . datasender cxt . dummy data read file fd = = NULL ) { if ( t thrd . datasender cxt . dummy data read file num > t thrd . datarcvwriter cxt . dummy data writer file num ) { ereport ( DEBUG5 , ( errmsg ( \" no data to send . dummy data read file num = % u \" , t thrd . datasender cxt . dummy data read file num ) ) ) ; if ( total len > bufsize ) ereport ( PANIC , ( errmsg ( \" Secondery standby finish read data error , total len % u , bufsize % u \" , total len , bufsize ) ) ) ; return total len ; } n Ret = snprintf s ( path , sizeof ( path ) , MAXPGPATH - 1 , \" base / dummy standby / % u \" , t thrd . datasender cxt . dummy data read file num ) ; securec check ss ( n Ret , \" \\ 0 \" , \" \\ 0 \" ) ; ereport ( DEBUG5 , ( errmsg ( \" Data Send Read Data path = % s \" , path ) ) ) ; t thrd . datasender cxt . dummy data read file fd = fopen ( path , \" rb \" ) ; if ( t thrd . datasender cxt . dummy data read file fd = = NULL ) { ereport ( WARNING , ( errcode for file access ( ) , errmsg ( \" could not open data file \\ \" % s \\ \" : % m \" , path ) ) ) ; t thrd . datasender cxt . dummy data read file num + + ; } } for ( ; ; ) { bytesread = fread ( & nbytes , 1 , sizeof ( nbytes ) , t thrd . datasender cxt . dummy data read file fd ) ; if ( bytesread ! = sizeof ( nbytes ) ) { if ( ferror ( t thrd . datasender cxt . dummy data read file fd ) ) { ereport ( PANIC , ( errcode for file access ( ) , errmsg ( \" could not read to data file % s length % u : % m \" , path , nbytes ) ) ) ; } if ( feof ( t thrd . datasender cxt . dummy data read file fd ) ) { ereport ( LOG , ( errmsg ( \" step1 : data file num % u , read file fd % d \" , t thrd . datasender cxt . dummy data read file num , t thrd . datasender cxt . dummy data read file fd - > fileno ) ) ) ; t thrd . datasender cxt . dummy data read file num + + ; fclose ( t thrd . datasender cxt . dummy data read file fd ) ; t thrd . datasender cxt . dummy data read file fd = NULL ; goto retry ; } } if ( total len + nbytes > bufsize ) { if ( fseek ( t thrd . datasender cxt . dummy data read file fd , - ( long ) sizeof ( nbytes ) , SEEK CUR ) ) ereport ( PANIC , ( errmsg ( \" fseek data file num % u error \" , t thrd . datasender cxt . dummy data read file num ) ) ) ; break ; } bytesread = fread ( buf + total len , 1 , nbytes , t thrd . datasender cxt . dummy data read file fd ) ; if ( bytesread ! = nbytes ) { if ( ferror ( t thrd . datasender cxt . dummy data read file fd ) ) { ereport ( PANIC , ( errcode for file access ( ) , errmsg ( \" could not read to data file % s length % u : % m \" , path , nbytes ) ) ) ; } if ( feof ( t thrd . datasender cxt . dummy data read file fd ) ) { ereport ( LOG , ( errmsg ( \" step2 : data file num % u , read file fd % d \" , t thrd . datasender cxt . dummy data read file num , t thrd . datasender cxt . dummy data read file fd - > fileno ) ) ) ; t thrd . datasender cxt . dummy data read file num + + ; fclose ( t thrd . datasender cxt . dummy data read file fd ) ; t thrd . datasender cxt . dummy data read file fd = NULL ; goto retry ; } } total len + = nbytes ; } if ( total len > bufsize ) ereport ( PANIC , ( errmsg ( \" Secondery standby read data error , total len % u , bufsize % u \" , total len , bufsize ) ) ) ; return total len ; }", "predictions": ["function function: < br / >"], "references": ["the data transmitter reads the data"], "bleu": 0.18575057999133598, "rouge_l": 0.0}
{"id": 91, "code": "void Data Rcv Send Reply ( bool force , bool request Reply ) { volatile Data Rcv Data * datarcv = t thrd . datareceiver cxt . Data Rcv ; char buf [ sizeof ( Standby Data Reply Message ) + 1 ] = { 0 } ; Timestamp Tz now ; Data Queue Ptr receive Position ; errno t errorno = EOK ; if ( ! force & & u sess - > attr . attr storage . wal receiver status interval < = 0 ) return ; now = Get Current Timestamp ( ) ; Spin Lock Acquire ( & datarcv - > mutex ) ; receive Position . queueid = datarcv - > receive Position . queueid ; receive Position . queueoff = datarcv - > receive Position . queueoff ; Spin Lock Release ( & datarcv - > mutex ) ; if ( ! force & & ( DQByteEQ ( t thrd . datareceiver cxt . reply message - > receive Position , receive Position ) ) & & ! ( Timestamp Difference Exceeds ( t thrd . datareceiver cxt . reply message - > send Time , now , u sess - > attr . attr storage . wal receiver status interval * 1000 ) | | Timestamp Difference Exceeds ( now , t thrd . datareceiver cxt . reply message - > send Time , u sess - > attr . attr storage . wal receiver status interval * 1000 ) ) ) { return ; } t thrd . datareceiver cxt . reply message - > receive Position = receive Position ; t thrd . datareceiver cxt . reply message - > send Time = now ; t thrd . datareceiver cxt . reply message - > reply Requested = request Reply ; ereport ( DEBUG2 , ( errmsg ( \" sending data receive queue position % u / % u \" , t thrd . datareceiver cxt . reply message - > receive Position . queueid , t thrd . datareceiver cxt . reply message - > receive Position . queueoff ) ) ) ; buf [ 0 ] = ' r ' ; errorno = memcpy s ( & buf [ 1 ] , sizeof ( Standby Data Reply Message ) , t thrd . datareceiver cxt . reply message , sizeof ( Standby Data Reply Message ) ) ; securec check ( errorno , \" \" , \" \" ) ; Data Rcv Stream Send ( buf , sizeof ( Standby Data Reply Message ) + 1 ) ; }", "predictions": ["this method"], "references": ["sending and response of data receiver"], "bleu": 0.08647154598524984, "rouge_l": 0.0}
{"id": 92, "code": "static void Data Rcv Receive ( char * buf , Size nbytes ) { Block Number cursegno = Invalid Block Number ; Data Element Header Data dataelemheader ; uint32 currentlen = 0 ; int headerlen = sizeof ( Data Element Header Data ) ; errno t rc = 0 ; # ifdef DATA DEBUG pg crc32 crc ; # endif while ( nbytes > = sizeof ( uint32 ) + sizeof ( Data Element Header Data ) ) { rc = memcpy s ( ( void * ) & currentlen , sizeof ( uint32 ) , buf , sizeof ( uint32 ) ) ; securec check ( rc , \" \" , \" \" ) ; buf + = sizeof ( uint32 ) ; rc = memcpy s ( ( void * ) & dataelemheader , headerlen , buf , headerlen ) ; securec check ( rc , \" \" , \" \" ) ; buf + = headerlen ; if ( u sess - > attr . attr storage . Ha Module Debug ) { ereport ( LOG , ( errmsg ( \" Data Rcv Receive element info : % u , % u , % u , % u \" , dataelemheader . rnode . db Node , dataelemheader . rnode . spc Node , dataelemheader . rnode . rel Node , GETATTID ( ( uint ) dataelemheader . attid ) ) ) ) ; } cursegno = dataelemheader . blocknum / ( ( Block Number ) RELSEG SIZE ) ; if ( currentlen ! = ( sizeof ( uint32 ) + ( uint32 ) headerlen + ( uint32 ) dataelemheader . data size ) ) { ereport ( ERROR , ( errmsg ( \" Current length is illegal , the data Rcv Receiveelement info is : % u , % u , % u , % d \" , dataelemheader . rnode . db Node , dataelemheader . rnode . spc Node , dataelemheader . rnode . rel Node , GETATTID ( dataelemheader . attid ) ) ) ) ; } if ( u sess - > attr . attr storage . Ha Module Debug ) { ereport ( LOG , ( errmsg ( \" HA - Data Rcv Receive : rnode % u / % u / % u , blockno % u , segno % u , \" \" pageoffset2blockno % lu , size % u , queueoffset % u / % u \" , dataelemheader . rnode . spc Node , dataelemheader . rnode . db Node , dataelemheader . rnode . rel Node , dataelemheader . blocknum , cursegno , dataelemheader . offset / BLCKSZ , dataelemheader . data size , dataelemheader . queue offset . queueid , dataelemheader . queue offset . queueoff ) ) ) ; } Data Rcv Send Reply ( false , false ) ; # ifdef DATA DEBUG INIT CRC32 ( crc ) ; COMP CRC32 ( crc , buf , dataelemheader . data size ) ; FIN CRC32 ( crc ) ; if ( ! EQ CRC32 ( dataelemheader . data crc , crc ) ) { ereport ( PANIC , ( errmsg ( \" received incorrect data page checksum at : \" \" rnode [ % u , % u , % u ] , blockno [ % u ] , segno [ % u ] , \" \" pageoffset [ % u ] , size [ % u ] , queueoffset [ % u / % u ] \" , dataelemheader . rnode . spc Node , dataelemheader . rnode . db Node , dataelemheader . rnode . rel Node , dataelemheader . blocknum , cursegno , dataelemheader . offset , dataelemheader . data size , dataelemheader . queue offset . queueid , dataelemheader . queue offset . queueoff ) ) ) ; } # endif ( void ) Push To Writer Queue ( buf - sizeof ( uint32 ) - headerlen , currentlen ) ; buf + = dataelemheader . data size ; nbytes - = currentlen ; Wakeup Data Rcv Writer ( ) ; } Assert ( nbytes = = 0 ) ; Wakeup Data Rcv Writer ( ) ; }", "predictions": ["function function: < br / >"], "references": ["data is received from the remote server and pushed to the writer queue."], "bleu": 0.0578433294533084, "rouge_l": 0.0}
{"id": 93, "code": "static const char * Data Snd Get State String ( Data Snd State state ) { switch ( state ) { case DATASNDSTATE STARTUP : return \" Startup \" ; case DATASNDSTATE CATCHUP : return \" Catchup \" ; case DATASNDSTATE STREAMING : return \" Streaming \" ; } return \" Unknown \" ; }", "predictions": ["get the"], "references": ["according to the status captured by the system, the recognizable status word is returned"], "bleu": 0.00188344435971766, "rouge_l": 0.11010830324909747}
{"id": 94, "code": "bool Wal Rcv Is Done ( ) { if ( g instance . attr . attr storage . enable mix replication ) return Data Queue Is Empty ( t thrd . dataqueue cxt . Data Writer Queue ) ; else return wal Rcv Ctl Block Is Empty ( ) ; }", "predictions": ["Done"], "references": ["this method is used to judge whether the wal log receiver is finished or not"], "bleu": 6.992295190747032e-07, "rouge_l": 0.0}
{"id": 95, "code": "static void BCMReset Meta Bit ( Relation rel , Block Number metablk , int col ) { Block Number metablock = 1 ; Buffer metabuffer = Invalid Buffer ; Page page ; unsigned char * map = NULL ; uint32 bshift = 0 ; BCMBit Status page Status0 = 0 ; BCMBit Status page Status1 = 0 ; int i = 0 ; int j = 0 ; bool dirty = false ; for ( metablock = 1 ; metablock < metablk ; metablock + = ( META BLOCKS PER PAGE + 1 ) ) { metabuffer = BCM readbuf ( rel , metablock , false , col ) ; if ( ! Buffer Is Valid ( metabuffer ) ) ereport ( ERROR , ( errcode ( ERRCODE DATA CORRUPTED ) , errmsg ( \" % u / % u / % u invalid bcm meta buffer % u \" , rel - > rd node . spc Node , rel - > rd node . db Node , rel - > rd node . rel Node , metablock ) ) ) ; Lock Buffer ( metabuffer , BUFFER LOCK EXCLUSIVE ) ; page = Buffer Get Page ( metabuffer ) ; map = ( unsigned char * ) Page Get Contents ( page ) ; ereport ( DEBUG1 , ( errmsg ( \" relation % u / % u / % u col % d try to reset meta block % u \" , rel - > rd node . spc Node , rel - > rd node . db Node , rel - > rd node . rel Node , col , metablock ) ) ) ; START CRIT SECTION ( ) ; for ( i = 0 ; i < ( int ) BCMMAPSIZE ; i + + ) { for ( j = 0 ; j < META BLOCKS PER BYTE ; j + + ) { bshift = ( uint32 ) j * META BITS PER BLOCK ; page Status0 = ( ( map [ i ] > > bshift ) & META SYNC0 BITMASK ) > > 3 ; Assert ( SYNCED = = page Status0 | | NOTSYNCED = = page Status0 ) ; page Status1 = ( ( map [ i ] > > bshift ) & META SYNC1 BITMASK ) > > 1 ; Assert ( SYNCED = = page Status1 | | NOTSYNCED = = page Status1 ) ; if ( SYNCED = = page Status0 & & NOTSYNCED = = page Status1 ) { SET SYNC1 BYTE STATUS ( map [ i ] , SYNCED , bshift ) ; dirty = true ; } } } if ( dirty ) Mark Buffer Dirty ( metabuffer ) ; END CRIT SECTION ( ) ; Unlock Release Buffer ( metabuffer ) ; } return ; }", "predictions": ["this method"], "references": ["this function is used to reset the synchronization state of the bcm page"], "bleu": 0.003105274778046689, "rouge_l": 0.11776061776061778}
{"id": 96, "code": "Size Data Queue Shmem Size ( void ) { Size size = 0 ; / / if ( ! IS SINGLE NODE ) { Assert ( g instance . attr . attr storage . Data Queue Buf Size > 0 ) ; size = sizeof ( Data Queue Data ) ; size = add size ( size , ALIGNOF BUFFER ) ; size = add size ( size , g instance . attr . attr storage . Data Queue Buf Size * 1024 ) ; } return size ; }", "predictions": ["this function is used to add"], "references": ["define data queue size"], "bleu": 0.18575057999133598, "rouge_l": 0.0}
{"id": 97, "code": "static void heartbeat sighup handler ( SIGNAL ARGS ) { t thrd . heartbeat cxt . got SIGHUP = true ; }", "predictions": ["function function:"], "references": ["processing of sighup instruction"], "bleu": 0.23505403213046533, "rouge_l": 0.0}
{"id": 98, "code": "bool Wal Snd In Progress ( int type ) { int i ; for ( i = 0 ; i < g instance . attr . attr storage . max wal senders ; i + + ) { volatile Wal Snd * walsnd = & t thrd . walsender cxt . Wal Snd Ctl - > walsnds [ i ] ; Spin Lock Acquire ( & walsnd - > mutex ) ; if ( walsnd - > pid ! = 0 & & walsnd - > pid ! = t thrd . proc cxt . My Proc Pid & & ( ( walsnd - > send Role & type ) = = walsnd - > send Role ) ) { Spin Lock Release ( & walsnd - > mutex ) ; return true ; } Spin Lock Release ( & walsnd - > mutex ) ; } return false ; }", "predictions": ["this method"], "references": ["check whether there is wal sender"], "bleu": 0.08647154598524984, "rouge_l": 0.0}
{"id": 99, "code": "void Wal Snd Signals ( void ) { ( void ) gspqsignal ( SIGHUP , Wal Snd Sig Hup Handler ) ; ( void ) gspqsignal ( SIGINT , SIG IGN ) ; ( void ) gspqsignal ( SIGTERM , Wal Snd Shutdown Handler ) ; ( void ) gspqsignal ( SIGQUIT , Wal Snd Quick Die Handler ) ; ( void ) gspqsignal ( SIGALRM , handle sig alarm ) ; ( void ) gspqsignal ( SIGPIPE , SIG IGN ) ; ( void ) gspqsignal ( SIGUSR1 , Wal SndXLog Send Handler ) ; ( void ) gspqsignal ( SIGUSR2 , Wal Snd Last Cycle Handler ) ; ( void ) gspqsignal ( SIGCHLD , SIG DFL ) ; ( void ) gspqsignal ( SIGTTIN , SIG DFL ) ; ( void ) gspqsignal ( SIGTTOU , SIG DFL ) ; ( void ) gspqsignal ( SIGCONT , SIG DFL ) ; ( void ) gspqsignal ( SIGWINCH , SIG DFL ) ; }", "predictions": ["function function:"], "references": ["this method is used to set the signal processing program of wal log sender"], "bleu": 0.0015837816104164078, "rouge_l": 0.0}
{"id": 100, "code": "void Data Snd Set State ( Data Snd State state ) { volatile Data Snd * datasnd = t thrd . datasender cxt . My Data Snd ; Assert ( t thrd . datasender cxt . am datasender ) ; if ( datasnd - > state = = state ) return ; Spin Lock Acquire ( & datasnd - > mutex ) ; datasnd - > state = state ; if ( state = = DATASNDSTATE CATCHUP ) datasnd - > catchup Time [ 0 ] = Get Current Timestamp ( ) ; else if ( state = = DATASNDSTATE STREAMING ) datasnd - > catchup Time [ 1 ] = Get Current Timestamp ( ) ; Spin Lock Release ( & datasnd - > mutex ) ; }", "predictions": ["this function is used to be"], "references": ["sets the status for the current data sending process (called only during data transmission)."], "bleu": 0.048963321289052536, "rouge_l": 0.0}
{"id": 101, "code": "static void wal get ha rebuild reason with dummy ( char * build Reason , Server Mode local role , bool is Running ) { volatile Wal Rcv Data * walrcv = t thrd . walreceiverfuncs cxt . Wal Rcv ; volatile Ha Shmem Data * hashmdata = t thrd . postmaster cxt . Ha Shm Data ; int n Ret = 0 ; if ( local role = = NORMAL MODE | | local role = = PRIMARY MODE ) { n Ret = snprintf s ( build Reason , MAXFNAMELEN , MAXFNAMELEN - 1 , \" % s \" , \" Normal \" ) ; securec check ss ( n Ret , \" \\ 0 \" , \" \\ 0 \" ) ; return ; } if ( t thrd . postmaster cxt . Repl Conn Array [ 1 ] ! = NULL & & walrcv - > conn target = = REPCONNTARGET PRIMARY ) { if ( hashmdata - > repl reason [ 1 ] = = NONE REBUILD & & is Running ) { n Ret = snprintf s ( build Reason , MAXFNAMELEN , MAXFNAMELEN - 1 , \" % s \" , \" Normal \" ) ; securec check ss ( n Ret , \" \\ 0 \" , \" \\ 0 \" ) ; } else if ( hashmdata - > repl reason [ 1 ] = = NONE REBUILD & & ! is Running ) { n Ret = snprintf s ( build Reason , MAXFNAMELEN , MAXFNAMELEN - 1 , \" % s \" , \" Connecting . . . \" ) ; securec check ss ( n Ret , \" \\ 0 \" , \" \\ 0 \" ) ; } else { n Ret = snprintf s ( build Reason , MAXFNAMELEN , MAXFNAMELEN - 1 , \" % s \" , wal get rebuild reason string ( hashmdata - > repl reason [ 1 ] ) ) ; securec check ss ( n Ret , \" \\ 0 \" , \" \\ 0 \" ) ; } } else if ( t thrd . postmaster cxt . Repl Conn Array [ 2 ] ! = NULL & & walrcv - > conn target = = REPCONNTARGET DUMMYSTANDBY ) { if ( hashmdata - > repl reason [ 2 ] = = NONE REBUILD & & is Running ) { n Ret = snprintf s ( build Reason , MAXFNAMELEN , MAXFNAMELEN - 1 , \" % s \" , \" Normal \" ) ; securec check ss ( n Ret , \" \\ 0 \" , \" \\ 0 \" ) ; } else if ( hashmdata - > repl reason [ 2 ] = = NONE REBUILD & & ! is Running ) { n Ret = snprintf s ( build Reason , MAXFNAMELEN , MAXFNAMELEN - 1 , \" % s \" , \" Connecting . . . \" ) ; securec check ss ( n Ret , \" \\ 0 \" , \" \\ 0 \" ) ; } else { n Ret = snprintf s ( build Reason , MAXFNAMELEN , MAXFNAMELEN - 1 , \" % s \" , wal get rebuild reason string ( hashmdata - > repl reason [ 2 ] ) ) ; securec check ss ( n Ret , \" \\ 0 \" , \" \\ 0 \" ) ; } } else { n Ret = snprintf s ( build Reason , MAXFNAMELEN , MAXFNAMELEN - 1 , \" % s \" , \" Disconnected \" ) ; securec check ss ( n Ret , \" \\ 0 \" , \" \\ 0 \" ) ; } }", "predictions": ["this function is used to obtain"], "references": ["wal get ha rebuild reason with dummy. < br / > wal: write ahead logging. the standard method to realize transaction log is to persist the corresponding log before persisting the data file (the carrier of table and index). < br / > ha: high availability"], "bleu": 0.0003111099823019381, "rouge_l": 0.06755260243632337}
{"id": 102, "code": "static void Wal SndXLog Send Handler ( SIGNAL ARGS ) { int save errno = errno ; latch sigusr1 handler ( ) ; errno = save errno ; }", "predictions": ["this function is used to be"], "references": ["set the flag to send the wal record"], "bleu": 0.15827883685397307, "rouge_l": 0.13926940639269406}
{"id": 103, "code": "static void Data Snd Kill ( int code , Datum arg ) { Data Snd * datasnd = t thrd . datasender cxt . My Data Snd ; Assert ( t thrd . datasender cxt . My Data Snd ! = NULL ) ; t thrd . datasender cxt . My Data Snd = NULL ; Disown Latch ( & datasnd - > latch ) ; if ( code > 0 ) { pg usleep ( 100000 L ) ; } Spin Lock Acquire ( & datasnd - > mutex ) ; datasnd - > pid = 0 ; Spin Lock Release ( & datasnd - > mutex ) ; dummy Searching = false ; ereport ( LOG , ( errmsg ( \" datasender thread shut down \" ) ) ) ; }", "predictions": ["this function is used to be"], "references": ["destroy every data structure that this process processes"], "bleu": 0.15827883685397307, "rouge_l": 0.13926940639269406}
{"id": 104, "code": "static void set Wal Rcv Writer Latch ( void ) { volatile Wal Rcv Data * walrcv = t thrd . walreceiverfuncs cxt . Wal Rcv ; Spin Lock Acquire ( & walrcv - > mutex ) ; walrcv - > walrcv Writer Latch = & t thrd . proc - > proc Latch ; walrcv - > writer Pid = t thrd . proc cxt . My Proc Pid ; Spin Lock Release ( & walrcv - > mutex ) ; }", "predictions": ["this method"], "references": ["set the latch of wallcvwriter to prevent it from being interrupted during process execution."], "bleu": 0.0015837816104164078, "rouge_l": 0.0}
{"id": 105, "code": "bool Snap Build Process Change ( Snap Build * builder , Transaction Id xid , XLog Rec Ptr lsn ) { if ( builder - > state < SNAPBUILD FULL SNAPSHOT ) return false ; if ( builder - > state < SNAPBUILD CONSISTENT & & Transaction Id Precedes ( xid , Snap Build Next Phase At ( builder ) ) ) return false ; if ( ! Reorder Buffer Xid Has Base Snapshot ( builder - > reorder , xid ) ) { if ( builder - > snapshot = = NULL ) { builder - > snapshot = Snap Build Build Snapshot ( builder , xid ) ; Snap Build Snap Inc Refcount ( builder - > snapshot ) ; } Snap Build Snap Inc Refcount ( builder - > snapshot ) ; Reorder Buffer Set Base Snapshot ( builder - > reorder , xid , lsn , builder - > snapshot ) ; } return true ; }", "predictions": ["this method"], "references": ["handles the impact of individual heap changes that are appropriate for the current state"], "bleu": 0.0015837816104164078, "rouge_l": 0.0}
{"id": 106, "code": "static void Sync Rep Notify Complete ( ) { SHM QUEUE * next Element = t thrd . proc - > sync Rep Links . next ; if ( next Element ) { t thrd . proc - > sync Rep Links . next = NULL ; while ( next Element ! = NULL ) { PGPROC * cur Proc = ( PGPROC * ) ( ( ( char * ) next Element ) - offsetof ( PGPROC , sync Rep Links ) ) ; next Element = cur Proc - > sync Rep Links . next ; cur Proc - > sync Rep Links . next = NULL ; cur Proc - > sync Rep Links . prev = NULL ; pg write barrier ( ) ; cur Proc - > sync Rep State = SYNC REP WAIT COMPLETE ; Set Latch ( & ( cur Proc - > proc Latch ) ) ; } } }", "predictions": ["this function is used to be"], "references": ["the higher priority process tells the following processes that it has completed execution."], "bleu": 0.0578433294533084, "rouge_l": 0.0}
{"id": 107, "code": "void Set Wal Rcv WriterPID ( Thread Id tid ) { volatile Wal Rcv Data * walrcv = t thrd . walreceiverfuncs cxt . Wal Rcv ; Spin Lock Acquire ( & walrcv - > mutex ) ; walrcv - > writer Pid = tid ; Spin Lock Release ( & walrcv - > mutex ) ; }", "predictions": ["this method"], "references": ["set the writerpid of the wallrcv process and pass the parameter as the process id (tid)."], "bleu": 0.0005826406937775951, "rouge_l": 0.0}
{"id": 108, "code": "static void wal get ha rebuild reason with multi ( char * build Reason , Server Mode local role , bool is Running ) { volatile Wal Rcv Data * walrcv = t thrd . walreceiverfuncs cxt . Wal Rcv ; volatile Ha Shmem Data * hashmdata = t thrd . postmaster cxt . Ha Shm Data ; int rcs = 0 ; if ( local role = = NORMAL MODE | | local role = = PRIMARY MODE ) { rcs = snprintf s ( build Reason , MAXFNAMELEN , MAXFNAMELEN - 1 , \" % s \" , \" Normal \" ) ; securec check ss ( rcs , \" \\ 0 \" , \" \\ 0 \" ) ; return ; } if ( t thrd . postmaster cxt . Repl Conn Array [ hashmdata - > current repl ] ! = NULL & & walrcv - > conn target = = REPCONNTARGET PRIMARY ) { if ( hashmdata - > repl reason [ hashmdata - > current repl ] = = NONE REBUILD & & is Running ) { rcs = snprintf s ( build Reason , MAXFNAMELEN , MAXFNAMELEN - 1 , \" % s \" , \" Normal \" ) ; securec check ss ( rcs , \" \\ 0 \" , \" \\ 0 \" ) ; } else if ( hashmdata - > repl reason [ hashmdata - > current repl ] = = NONE REBUILD & & ! is Running ) { rcs = snprintf s ( build Reason , MAXFNAMELEN , MAXFNAMELEN - 1 , \" % s \" , \" Connecting . . . \" ) ; securec check ss ( rcs , \" \\ 0 \" , \" \\ 0 \" ) ; } else { rcs = snprintf s ( build Reason , MAXFNAMELEN , MAXFNAMELEN - 1 , \" % s \" , wal get rebuild reason string ( hashmdata - > repl reason [ hashmdata - > current repl ] ) ) ; securec check ss ( rcs , \" \\ 0 \" , \" \\ 0 \" ) ; } } else { rcs = snprintf s ( build Reason , MAXFNAMELEN , MAXFNAMELEN - 1 , \" % s \" , \" Disconnected \" ) ; securec check ss ( rcs , \" \\ 0 \" , \" \\ 0 \" ) ; } }", "predictions": ["this function is used to obtain"], "references": ["wal get ha rebuild reason with multiple. < br / > wal: write ahead logging. the standard method to realize transaction log is to persist the corresponding log before persisting the data file (the carrier of table and index). < br / > ha: high availability"], "bleu": 0.0003111099823019381, "rouge_l": 0.06755260243632337}
{"id": 109, "code": "static void heartbeat sigusr1 handler ( SIGNAL ARGS ) { int save errno = errno ; latch sigusr1 handler ( ) ; errno = save errno ; }", "predictions": ["this function is used to save"], "references": ["this static function is used for latch up"], "bleu": 0.31149111610852515, "rouge_l": 0.5570776255707762}
{"id": 110, "code": "static bool Wal Snd Caughtup ( void ) { int i ; for ( i = 0 ; i < g instance . attr . attr storage . max wal senders ; i + + ) { volatile Wal Snd * walsnd = & t thrd . walsender cxt . Wal Snd Ctl - > walsnds [ i ] ; Spin Lock Acquire ( & walsnd - > mutex ) ; if ( walsnd - > pid ! = 0 & & walsnd - > send Role = = SNDROLE PRIMARY STANDBY & & walsnd - > state = = WALSNDSTATE STREAMING ) { Spin Lock Release ( & walsnd - > mutex ) ; return true ; } Spin Lock Release ( & walsnd - > mutex ) ; } return false ; }", "predictions": ["this function is used to be"], "references": ["judge whether the primary server is occupied or not, and return true if it is occupied"], "bleu": 0.041721848418993325, "rouge_l": 0.0840220385674931}
{"id": 111, "code": "void Data Snd Shmem Init ( void ) { bool found = false ; int i ; errno t rc = 0 ; t thrd . datasender cxt . Data Snd Ctl = ( Data Snd Ctl Data * ) Shmem Init Struct ( \" Data Sender Ctl \" , Data Snd Shmem Size ( ) , & found ) ; if ( ! found ) { rc = memset s ( t thrd . datasender cxt . Data Snd Ctl , Data Snd Shmem Size ( ) , 0 , Data Snd Shmem Size ( ) ) ; securec check ( rc , \" \" , \" \" ) ; SHMQueue Init ( & ( t thrd . datasender cxt . Data Snd Ctl - > Sync Rep Queue ) ) ; for ( i = 0 ; i < g instance . attr . attr storage . max wal senders ; i + + ) { Data Snd * datasnd = & t thrd . datasender cxt . Data Snd Ctl - > datasnds [ i ] ; rc = memset s ( datasnd , sizeof ( Data Snd ) , 0 , sizeof ( Data Snd ) ) ; securec check ( rc , \" \" , \" \" ) ; datasnd - > send Keepalive = true ; Spin Lock Init ( & datasnd - > mutex ) ; Init Shared Latch ( & datasnd - > latch ) ; } Spin Lock Init ( & t thrd . datasender cxt . Data Snd Ctl - > mutex ) ; } }", "predictions": ["this method"], "references": ["allocates and initializes shared memory associated with data numbering"], "bleu": 0.019294409903971108, "rouge_l": 0.0}
{"id": 112, "code": "static void Process Replies If Any ( void ) { unsigned char firstchar ; int r ; bool received = false ; for ( ; ; ) { r = pq getbyte if available ( & firstchar ) ; if ( r < 0 ) { ereport ( COMMERROR , ( errcode ( ERRCODE PROTOCOL VIOLATION ) , errmsg ( \" unexpected EOF on standby connection \" ) ) ) ; proc exit ( 0 ) ; } if ( r = = 0 ) { break ; } switch ( firstchar ) { case ' d ' : Process Standby Message ( ) ; received = true ; break ; case ' c ' : case ' X ' : proc exit ( 0 ) ; default : ereport ( FATAL , ( errcode ( ERRCODE PROTOCOL VIOLATION ) , errmsg ( \" invalid standby message type \\ \" % c \\ \" \" , firstchar ) ) ) ; } } if ( received ) { t thrd . walsender cxt . last reply timestamp = Get Current Timestamp ( ) ; t thrd . walsender cxt . waiting for ping response = false ; } else { Timestamp Tz now = Get Current Timestamp ( ) ; Wal Snd Check Time Out ( now ) ; Wal Snd Keepalive If Necessary ( now ) ; } }", "predictions": ["Replies"], "references": ["this function is used to determine whether the remote host has closed the connection"], "bleu": 1.9007028956229227e-06, "rouge_l": 0.0}
{"id": 113, "code": "Heartbeat Client : : ~ Heartbeat Client ( ) { Dis Connect ( ) ; }", "predictions": ["get the"], "references": ["concretization of destructors"], "bleu": 0.38753858253732953, "rouge_l": 0.0}
{"id": 114, "code": "static void Data Snd Sig Hup Handler ( SIGNAL ARGS ) { int save errno = errno ; t thrd . datasender cxt . got SIGHUP = true ; if ( t thrd . datasender cxt . My Data Snd ) Set Latch ( & t thrd . datasender cxt . My Data Snd - > latch ) ; errno = save errno ; }", "predictions": ["this function is used to save"], "references": ["set an identity at the next convenient time to reread the configuration file"], "bleu": 0.06878769894132081, "rouge_l": 0.09870550161812298}
{"id": 115, "code": "Heartbeat Client : : Heartbeat Client ( int epollfd ) : epollfd ( epollfd ) , is Connect ( false ) , hb Conn ( NULL ) { }", "predictions": ["get the"], "references": ["initialize class members"], "bleu": 0.38753858253732953, "rouge_l": 0.0}
{"id": 116, "code": "void Set Wal Rcv Dummy Standby Sync Percent ( int percent ) { volatile Wal Rcv Data * walrcv = t thrd . walreceiverfuncs cxt . Wal Rcv ; Spin Lock Acquire ( & walrcv - > mutex ) ; walrcv - > dummy Standby Sync Percent = percent ; Spin Lock Release ( & walrcv - > mutex ) ; }", "predictions": ["this method"], "references": ["setting the synchronization rate of dummy backup in wal receiver"], "bleu": 0.011702651167821564, "rouge_l": 0.0}
{"id": 117, "code": "static int WSXLog Page Read ( XLog Reader State * xlogreader , XLog Rec Ptr target Page Ptr , int req Len , XLog Rec Ptr target Rec Ptr , char * read Buf , Time LineID * pageTLI ) { WSXLog Page Read Private * ws private = ( WSXLog Page Read Private * ) xlogreader - > private data ; uint32 target Page Off ; int n Ret Code = 0 ; char xlogfile [ MAXFNAMELEN ] ; char xlogfpath [ MAXPGPATH ] ; if ( ws private = = NULL ) { Assert ( false ) ; ereport ( WARNING , ( errmsg ( \" The WAL Streaming XLog Reader Private Info is NULL . \" ) ) ) ; return - 1 ; } if ( ws private - > xlogreadfd > = 0 & & ! XLByte In Seg ( target Page Ptr , ws private - > xlogreadlogsegno ) ) { ( void ) close ( ws private - > xlogreadfd ) ; ws private - > xlogreadfd = - 1 ; } XLByte To Seg ( target Page Ptr , ws private - > xlogreadlogsegno ) ; if ( ws private - > xlogreadfd < 0 ) { XLog File Name ( xlogfile , ws private - > tli , ws private - > xlogreadlogsegno ) ; n Ret Code = snprintf s ( xlogfpath , MAXPGPATH , MAXPGPATH - 1 , XLOGDIR \" / % s \" , xlogfile ) ; securec check ss ( n Ret Code , \" \\ 0 \" , \" \\ 0 \" ) ; ws private - > xlogreadfd = Basic Open File ( xlogfpath , O RDONLY | PG BINARY , 0 ) ; if ( ws private - > xlogreadfd < 0 ) { ereport ( DEBUG2 , ( errmsg ( \" could not open the xlog file % s : % s . \" , xlogfpath , gs strerror ( errno ) ) ) ) ; return - 1 ; } } target Page Off = target Page Ptr % XLog Seg Size ; if ( lseek ( ws private - > xlogreadfd , ( off t ) target Page Off , SEEK SET ) < 0 ) { Assert ( false ) ; ereport ( WARNING , ( errmsg ( \" could not seek % u bytes in the file % s : % s . \" , target Page Off , xlogfpath , gs strerror ( errno ) ) ) ) ; return - 1 ; } if ( read ( ws private - > xlogreadfd , read Buf , XLOG BLCKSZ ) ! = XLOG BLCKSZ ) { Assert ( false ) ; ereport ( WARNING , ( errmsg ( \" could not read the request % d bytes in the xlog file % s : % s . \" , req Len , xlogfpath , gs strerror ( errno ) ) ) ) ; return - 1 ; } * pageTLI = ws private - > tli ; return XLOG BLCKSZ ; }", "predictions": ["this method"], "references": ["function is used to read the position of the first record after the targetreptr position"], "bleu": 0.0009606121050066008, "rouge_l": 0.0}
{"id": 118, "code": "static int Wal Snd Loop ( Wal Snd Send Data Callback send data ) { bool first startup = true ; bool sync config needed = false ; bool marked stream replication = true ; Timestamp Tz last syncconf timestamp ; WSData Send Init ( ) ; init String Info ( t thrd . walsender cxt . reply message ) ; init String Info ( t thrd . walsender cxt . tmpbuf ) ; t thrd . walsender cxt . last reply timestamp = Get Current Timestamp ( ) ; last syncconf timestamp = Get Current Timestamp ( ) ; t thrd . walsender cxt . last logical xlog advanced timestamp = Get Current Timestamp ( ) ; t thrd . walsender cxt . waiting for ping response = false ; for ( ; ; ) { Timestamp Tz now ; Reset Latch ( & t thrd . walsender cxt . My Wal Snd - > latch ) ; # ifdef ENABLE DISTRIBUTE TEST if ( TEST STUB ( DN WALSEND MAINLOOP , stub sleep emit ) ) { ereport ( get distribute test param ( ) - > elevel , ( errmsg ( \" sleep emit happen during Wal Snd Loop time : % ds , stub name : % s \" , get distribute test param ( ) - > sleep time , get distribute test param ( ) - > test stub name ) ) ) ; } # endif pgstat report activity ( STATE RUNNING , NULL ) ; if ( ! Postmaster Is Alive ( ) ) gs thread exit ( 1 ) ; if ( t thrd . walsender cxt . got SIGHUP ) { t thrd . walsender cxt . got SIGHUP = false ; marked stream replication = u sess - > attr . attr storage . enable stream replication ; Process Config File ( PGC SIGHUP ) ; Sync Rep Init Config ( ) ; sync config needed = true ; } if ( catchup online & & t thrd . walsender cxt . Wal Snd Ctl - > demotion > No Demote ) { volatile Wal Snd * walsnd = t thrd . walsender cxt . My Wal Snd ; Spin Lock Acquire ( & t thrd . walsender cxt . Wal Snd Ctl - > mutex ) ; walsnd - > node state = NODESTATE PRIMARY DEMOTING WAIT CATCHUP ; Wal Snd Response Switchover ( t thrd . walsender cxt . output xlog message ) ; walsnd - > node state = NODESTATE NORMAL ; t thrd . walsender cxt . Wal Snd Ctl - > demotion = No Demote ; t thrd . walsender cxt . Demotion = No Demote ; Spin Lock Release ( & t thrd . walsender cxt . Wal Snd Ctl - > mutex ) ; ereport ( PANIC , ( errmsg ( \" walsender stop switchover process for catchup is alive , the process need to be restart \" ) ) ) ; } if ( ( t thrd . walsender cxt . walsender shutdown requested & & ! t thrd . walsender cxt . response switchover requested ) | | t thrd . walsender cxt . My Wal Snd - > node state = = NODESTATE STANDBY REDIRECT ) { if ( ! sync config needed ) { pq puttextmessage ( ' C ' , \" COPY 0 \" ) ; ( void ) pq flush ( ) ; proc exit ( 0 ) ; } } if ( u sess - > attr . attr storage . enable stream replication & & ! marked stream replication ) { marked stream replication = u sess - > attr . attr storage . enable stream replication ; Wal Snd Set State ( WALSNDSTATE CATCHUP ) ; } if ( t thrd . walsender cxt . response switchover requested ) { if ( t thrd . walsender cxt . My Wal Snd - > peer role ! = STANDBY MODE ) { ereport ( LOG , ( errmsg ( \" walsender closed because of switchover . \" ) ) ) ; proc exit ( 0 ) ; } } Process Replies If Any ( ) ; if ( first startup ) { Wal Snd Keepalive ( false ) ; first startup = false ; } if ( t thrd . walsender cxt . response switchover requested ) { XLog Rec Ptr Write Rqst Ptr ; uint32 XLog Page Off Set ; Write Rqst Ptr = GetXLog Insert End Rec Ptr ( ) ; XLog Page Off Set = Write Rqst Ptr % XLOG BLCKSZ ; ereport ( LOG , ( errmsg ( \" The WAL sender in primary is ready to do the switchover . \" ) ) ) ; ereport ( LOG , ( errmsg ( \" the latest WAL insert at % X / % X \" , ( uint32 ) ( Write Rqst Ptr > > 32 ) , ( uint32 ) Write Rqst Ptr ) ) ) ; if ( Size OfXLog LongPHD = = XLog Page Off Set | | Size OfXLog ShortPHD = = Write Rqst Ptr % XLog Seg Size ) { Write Rqst Ptr - = XLog Page Off Set ; ereport ( LOG , ( errmsg ( \" the latest WAL insert back off to % X / % X \" , ( uint32 ) ( Write Rqst Ptr > > 32 ) , ( uint32 ) Write Rqst Ptr ) ) ) ; } if ( XLog Needs Flush ( Write Rqst Ptr ) ) { XLog Flush ( Write Rqst Ptr ) ; ereport ( LOG , ( errmsg ( \" the latest WAL flush to % X / % X . \" , ( uint32 ) ( Write Rqst Ptr > > 32 ) , ( uint32 ) Write Rqst Ptr ) ) ) ; } else { XLog Rec Ptr Send Rqst Ptr ; Send Rqst Ptr = AM WAL STANDBY SENDER ? Get Standby Flush Rec Ptr ( NULL ) : Get Flush Rec Ptr ( ) ; if ( XLByteLE ( Send Rqst Ptr , t thrd . walsender cxt . My Wal Snd - > flush ) & & ! t thrd . walsender cxt . wal send completed ) { t thrd . walsender cxt . wal send completed = true ; ereport ( LOG , ( errmsg ( \" the latest WAL complete at % X / % X \" , ( uint32 ) ( Send Rqst Ptr > > 32 ) , ( uint32 ) Send Rqst Ptr ) ) ) ; } else ereport ( LOG , ( errmsg ( \" the latest WAL flush at % X / % X the latest standby flush at % X / % X \" , ( uint32 ) ( Send Rqst Ptr > > 32 ) , ( uint32 ) Send Rqst Ptr , ( uint32 ) ( t thrd . walsender cxt . My Wal Snd - > flush > > 32 ) , ( uint32 ) t thrd . walsender cxt . My Wal Snd - > flush ) ) ) ; if ( ! Data Snd In Progress ( SNDROLE PRIMARY STANDBY | SNDROLE PRIMARY DUMMYSTANDBY ) & & ! Wal Snd In Progress ( SNDROLE PRIMARY DUMMYSTANDBY | SNDROLE PRIMARY STANDBY ) & & t thrd . walsender cxt . wal send completed ) { t thrd . walsender cxt . response switchover requested = false ; Wal Snd Response Switchover ( t thrd . walsender cxt . output xlog message ) ; ereport ( LOG , ( errmsg ( \" The WAL sender in primary has done the switchover waiting for the standby ' s promotion . \" ) ) ) ; } } } if ( sync config needed ) { if ( t thrd . walsender cxt . walsender shutdown requested ) { if ( ! AM WAL DB SENDER & & ! Send Config File ( t thrd . walsender cxt . gucconf file ) ) ereport ( LOG , ( errmsg ( \" failed to send config to the peer when walsender shutdown . \" ) ) ) ; sync config needed = false ; } else { Timestamp Tz nowtime = Get Current Timestamp ( ) ; if ( Timestamp Difference Exceeds ( last syncconf timestamp , nowtime , 1000 ) | | last syncconf timestamp > nowtime ) { sync config needed = false ; if ( t thrd . walsender cxt . My Wal Snd & & t thrd . walsender cxt . My Wal Snd - > peer state ! = BUILDING STATE ) { if ( ! AM WAL DB SENDER & & ! Send Config File ( t thrd . walsender cxt . gucconf file ) ) sync config needed = true ; else last syncconf timestamp = nowtime ; } else { sync config needed = false ; ereport ( LOG , ( errmsg ( \" receive sigup , but the peer is building ! \" ) ) ) ; } } } } if ( Am Wal Sender To Dummy Standby ( ) ) { if ( Wal Snd Caughtup ( ) ) { Wal Snd Caught Up = true ; t thrd . walsender cxt . sent Ptr = InvalidXLog Rec Ptr ; if ( t thrd . walsender cxt . send File > = 0 ) { ( void ) close ( t thrd . walsender cxt . send File ) ; t thrd . walsender cxt . send File = - 1 ; } if ( u sess - > attr . attr storage . Ha Module Debug ) { ereport ( LOG , ( errmsg ( \" standby is steaming , \" \" stop sync to walsender , recycle local data . \" ) ) ) ; } if ( Wal Snd DummyLEStandby ( ) ) { Wal Snd RmXLog ( false ) ; } if ( g instance . attr . attr storage . max replication slots > 0 ) Set Dummy Standby Slot Lsn Invalid ( ) ; } else { Choose Start Point For Dummy Standby ( ) ; if ( ! pq is send pending ( ) ) send data ( ) ; else Wal Snd Caught Up = false ; if ( Wal Snd Caught Up ) { if ( pq flush if writable ( ) ! = 0 ) break ; if ( ! pq is send pending ( ) ) Wal Snd Sync Dummy Standby Done ( false ) ; } } } else { if ( ! pq is send pending ( ) ) send data ( ) ; else Wal Snd Caught Up = false ; if ( Wal Snd Caught Up & & dummy Standby Mode ) { if ( ! pq is send pending ( ) ) { Wal Snd Sync Dummy Standby Done ( false ) ; ( void ) pq flush ( ) ; ereport ( LOG , ( errmsg ( \" dummystandby wal data replication completed at % X / % X \" , ( uint32 ) ( t thrd . walsender cxt . sent Ptr > > 32 ) , ( uint32 ) t thrd . walsender cxt . sent Ptr ) ) ) ; } } } if ( pq flush if writable ( ) ! = 0 ) { ereport ( LOG , ( errmsg ( \" flush return not zero ! \\ n \" ) ) ) ; break ; } if ( Wal Snd Caught Up & & ! pq is send pending ( ) ) { if ( t thrd . walsender cxt . My Wal Snd - > state = = WALSNDSTATE CATCHUP ) { ereport ( DEBUG1 , ( errmsg ( \" standby \\ \" % s \\ \" has now caught up with primary \" , u sess - > attr . attr common . application name ) ) ) ; Wal Snd Set State ( WALSNDSTATE STREAMING ) ; Wal Snd Keepalive ( true ) ; } t thrd . walsender cxt . catchup threshold = 0 ; if ( t thrd . walsender cxt . walsender ready to stop ) { if ( Am Wal Sender To Dummy Standby ( ) & & Wal Snd In Progress ( SNDROLE PRIMARY STANDBY ) ) ; else send data ( ) ; if ( Wal Snd Caught Up & & ! pq is send pending ( ) ) { if ( dummy Standby Mode | | XLByteEQ ( t thrd . walsender cxt . sent Ptr , t thrd . walsender cxt . My Wal Snd - > flush ) ) t thrd . walsender cxt . walsender shutdown requested = true ; } } } else { if ( t thrd . walsender cxt . My Wal Snd - > state = = WALSNDSTATE STREAMING & & ! XLByteLT ( t thrd . walsender cxt . catchup threshold , INT2UINT64 ( g instance . attr . attr storage . Max Send Size ) * 1024 ) ) { ereport ( DEBUG1 , ( errmsg ( \" standby \\ \" % s \\ \" has now caught up with primary \" , u sess - > attr . attr common . application name ) ) ) ; Wal Snd Set State ( WALSNDSTATE CATCHUP ) ; t thrd . walsender cxt . catchup threshold = 0 ; } } now = Get Current Timestamp ( ) ; if ( u sess - > proc cxt . My Database Id ! = Invalid Oid ) Wal Snd Write Logical AdvanceXLog ( now ) ; if ( Wal Snd Caught Up | | pq is send pending ( ) ) { long sleeptime ; int wake Events ; wake Events = WL LATCH SET | WL POSTMASTER DEATH | WL SOCKET READABLE | WL TIMEOUT ; sleeptime = Wal Snd Compute Sleeptime ( now ) ; if ( pq is send pending ( ) ) wake Events | = WL SOCKET WRITEABLE ; else if ( first startup ) { Wal Snd Keepalive ( false ) ; first startup = false ; } if ( t thrd . walsender cxt . response switchover requested | | t thrd . walsender cxt . walsender shutdown requested ) sleeptime = 100 ; pgstat report activity ( STATE IDLE , NULL ) ; t thrd . int cxt . Immediate InterruptOK = true ; CHECK FOR INTERRUPTS ( ) ; if ( sleeptime > u sess - > attr . attr storage . wal sender timeout / 2 ) sleeptime = u sess - > attr . attr storage . wal sender timeout / 2 ; Wait Latch Or Socket ( & t thrd . walsender cxt . My Wal Snd - > latch , wake Events , u sess - > proc cxt . My Proc Port - > sock , sleeptime ) ; t thrd . int cxt . Immediate InterruptOK = false ; } if ( ! b Sync Stat & & ! dummy Standby Mode ) { if ( XLByteEQ ( Get Flush Rec Ptr ( ) , t thrd . walsender cxt . sent Ptr ) & & Sync Rep Requested ( ) & & most available sync = = false ) { b Sync Stat = true ; ereport ( LOG , ( errmsg ( \" The primary and standby reached syncstat in Wal Snd Loop . \" ) ) ) ; } } } Wal Snd Shutdown ( ) ; return 1 ; }", "predictions": ["this method"], "references": ["main loop of data sending process"], "bleu": 0.08647154598524984, "rouge_l": 0.0}
{"id": 119, "code": "static void save xlogloc ( const char * xloglocation ) { errno t rc = 0 ; if ( 0 = = strncmp ( xloglocation , t thrd . proc cxt . Data Dir , strlen ( t thrd . proc cxt . Data Dir ) ) ) { rc = strncpy s ( t thrd . basebackup cxt . g xlog location , MAXPGPATH , xloglocation + strlen ( t thrd . proc cxt . Data Dir ) + 1 , MAXPGPATH - 1 ) ; securec check ( rc , \" \" , \" \" ) ; t thrd . basebackup cxt . g xlog location [ MAXPGPATH - 1 ] = ' \\ 0 ' ; } }", "predictions": ["this function is used to save"], "references": ["save xlog address"], "bleu": 0.22089591134157885, "rouge_l": 0.2364341085271318}
{"id": 120, "code": "static void Process Standby Search Message ( void ) { char * file List = NULL ; int msg Length = 0 ; if ( catchup State ! = CATCHUP SEARCHING ) { dummy Searching = false ; return ; } if ( t thrd . datasender cxt . reply message - > len = = 1 ) { catchup State = RECEIVED NONE ; pg memory barrier ( ) ; dummy Searching = false ; return ; } msg Length = t thrd . datasender cxt . reply message - > len - 1 ; file List = ( char * ) Memory Context Alloc Zero ( g instance . instance context , msg Length ) ; pq copymsgbytes ( t thrd . datasender cxt . reply message , file List , t thrd . datasender cxt . reply message - > len - 1 ) ; Replace Or Free Bcm File List Buffer ( file List , msg Length ) ; catchup State = RECEIVED OK ; pg memory barrier ( ) ; dummy Searching = false ; }", "predictions": ["this function file"], "references": ["the process stalled while processing search information."], "bleu": 0.11909345107359583, "rouge_l": 0.0}
{"id": 121, "code": "static void Data Snd Sync Standby Done ( bool request Reply ) { End Data Message end Data Message ; volatile Ha Shmem Data * hashmdata = t thrd . postmaster cxt . Ha Shm Data ; errno t errorno = EOK ; Spin Lock Acquire ( & hashmdata - > mutex ) ; end Data Message . peer role = hashmdata - > current mode ; Spin Lock Release ( & hashmdata - > mutex ) ; end Data Message . peer state = get local dbstate ( ) ; end Data Message . send Time = Get Current Timestamp ( ) ; end Data Message . percent = SYNC DUMMY STANDBY END ; ereport ( dummy Standby Mode ? LOG : DEBUG2 , ( errmsg ( \" sending standby end data message \" ) ) ) ; t thrd . datasender cxt . output message [ 0 ] = ' e ' ; errorno = memcpy s ( t thrd . datasender cxt . output message + 1 , sizeof ( Data Page Message Header ) + g instance . attr . attr storage . Max Send Size * 1024 , & end Data Message , sizeof ( End Data Message ) ) ; securec check ( errorno , \" \" , \" \" ) ; ( void ) pq putmessage noblock ( ' d ' , t thrd . datasender cxt . output message , sizeof ( End Data Message ) + 1 ) ; }", "predictions": ["this method"], "references": ["send terminal data message to backup."], "bleu": 0.08647154598524984, "rouge_l": 0.0}
{"id": 122, "code": "static void Data SndXLog Send Handler ( SIGNAL ARGS ) { int save errno = errno ; latch sigusr1 handler ( ) ; errno = save errno ; }", "predictions": ["save the file"], "references": ["set the flag to send the wal record"], "bleu": 0.10148002183214462, "rouge_l": 0.1680440771349862}
{"id": 123, "code": "static void Sync Rep Wait Completion Queue ( ) { int i = MAX SYNC REP RETRY COUNT ; while ( t thrd . proc - > sync Rep State = = SYNC REP WAITING ) { if ( i - - > 0 ) { pg usleep ( SYNC REP SLEEP DELAY ) ; } else { ereport ( WARNING , ( errmsg ( \" Waiting for syncrep completion queue timeout . \" ) ) ) ; i = MAX SYNC REP RETRY COUNT ; } } pg read barrier ( ) ; if ( t thrd . proc - > sync Rep State = = SYNC REP WAIT COMPLETE & & t thrd . proc - > sync Rep Links . next ) { Sync Rep Notify Complete ( ) ; } }", "predictions": ["this function is used to be"], "references": ["wait for the notification to complete in the queue. it should be done quickly, it's not about the network."], "bleu": 0.02800522812577658, "rouge_l": 0.1462829736211031}
{"id": 124, "code": "static void walrcv Writer Quick Die ( SIGNAL ARGS ) { gs signal setmask ( & t thrd . libpq cxt . Block Sig , NULL ) ; on exit reset ( ) ; gs thread exit ( 2 ) ; }", "predictions": ["this function is used to obtain"], "references": ["the static method can finish the wal log writing module continuously and quickly"], "bleu": 0.0578433294533084, "rouge_l": 0.0}
{"id": 125, "code": "static void BCMSet Meta Bit ( Relation rel , Block Number block , BCMBit Status status , int col ) { Block Number metablock = BCMBLK TO METABLOCK ( block ) ; int meta Byte = BCMBLK TO METABYTE ( block ) ; int meta Bit = BCMBLK TO METABIT ( block ) ; uint32 bshift = ( uint32 ) meta Bit * META BITS PER BLOCK ; Buffer metabuffer = Invalid Buffer ; BCMBit Status page Status0 = 0 ; BCMBit Status page Status1 = 0 ; Page page ; unsigned char * map = NULL ; Assert ( status = = SYNCED | | status = = NOTSYNCED ) ; metabuffer = BCM readbuf ( rel , metablock , false , col ) ; Assert ( Buffer Is Valid ( metabuffer ) ) ; Lock Buffer ( metabuffer , BUFFER LOCK EXCLUSIVE ) ; page = Buffer Get Page ( metabuffer ) ; map = ( unsigned char * ) Page Get Contents ( page ) ; page Status0 = ( ( map [ meta Byte ] > > bshift ) & META SYNC0 BITMASK ) > > 3 ; Assert ( page Status0 = = SYNCED | | page Status0 = = NOTSYNCED ) ; page Status1 = ( ( map [ meta Byte ] > > bshift ) & META SYNC1 BITMASK ) > > 1 ; Assert ( page Status1 = = SYNCED | | page Status1 = = NOTSYNCED ) ; if ( status ! = page Status0 | | status ! = page Status1 ) { START CRIT SECTION ( ) ; if ( status ! = page Status0 ) SET SYNC0 BYTE STATUS ( map [ meta Byte ] , status , bshift ) ; if ( status ! = page Status1 ) SET SYNC1 BYTE STATUS ( map [ meta Byte ] , status , bshift ) ; Mark Buffer Dirty ( metabuffer ) ; END CRIT SECTION ( ) ; } Unlock Release Buffer ( metabuffer ) ; }", "predictions": ["this function is used to status"], "references": ["set the value of bcm sync bit corresponding to the tracking page."], "bleu": 0.0812630644213965, "rouge_l": 0.10481099656357389}
{"id": 126, "code": "void Data Sender Queue Shmem Init ( void ) { const int buffernum = 1024 ; if ( ! IS SINGLE NODE | | IS DN DUMMY STANDYS MODE ( ) ) { bool found Data Queue = false ; char * allocptr = NULL ; errno t rc = 0 ; t thrd . dataqueue cxt . Data Sender Queue = ( Data Queue Data * ) Shmem Init Struct ( \" Data Sender Queue \" , Data Queue Shmem Size ( ) , & found Data Queue ) ; if ( found Data Queue ) { return ; } rc = memset s ( t thrd . dataqueue cxt . Data Sender Queue , sizeof ( Data Queue Data ) , 0 , sizeof ( Data Queue Data ) ) ; securec check c ( rc , \" \" , \" \" ) ; allocptr = ( ( char * ) t thrd . dataqueue cxt . Data Sender Queue ) + sizeof ( Data Queue Data ) ; allocptr = ( char * ) TYPEALIGN ( ALIGNOF BUFFER , allocptr ) ; t thrd . dataqueue cxt . Data Sender Queue - > pages = allocptr ; rc = memset s ( t thrd . dataqueue cxt . Data Sender Queue - > pages , ( INT2SIZET ( g instance . attr . attr storage . Data Queue Buf Size ) ) * buffernum , 0 , ( INT2SIZET ( g instance . attr . attr storage . Data Queue Buf Size ) ) * buffernum ) ; securec check c ( rc , \" \" , \" \" ) ; t thrd . dataqueue cxt . Data Sender Queue - > size = g instance . attr . attr storage . Data Queue Buf Size * buffernum ; Spin Lock Init ( & t thrd . dataqueue cxt . Data Sender Queue - > use mutex ) ; } }", "predictions": ["this method"], "references": ["define data transmitter"], "bleu": 0.38753858253732953, "rouge_l": 0.0}
{"id": 127, "code": "void BCMClear Rel ( Relation rel , int col ) { Block Number totalblocks = 0 ; Block Number map Block ; Fork Number forknum = BCM FORKNUM ; # ifdef TRACE BCMMAP elog ( LOG , \" BCMClear Rel % s \" , Relation Get Relation Name ( rel ) ) ; # endif if ( col > 0 ) { forknum = Column Id2 Col Fork Num ( col ) ; CStore Relation Open Smgr ( rel , col ) ; } else { Relation Open Smgr ( rel ) ; } if ( ! smgrexists ( rel - > rd smgr , forknum ) ) return ; totalblocks = smgrnblocks ( rel - > rd smgr , forknum ) ; if ( totalblocks = = 0 | | totalblocks = = 1 ) return ; for ( map Block = 1 ; map Block < totalblocks ; map Block + + ) { Buffer map Buffer ; unsigned char * map = NULL ; errno t rc = 0 ; map Buffer = BCM readbuf ( rel , map Block , false , col ) ; if ( ! Buffer Is Valid ( map Buffer ) ) ereport ( ERROR , ( errcode ( ERRCODE DATA CORRUPTED ) , errmsg ( \" % u / % u / % u invalid bcm buffer % u \" , rel - > rd node . spc Node , rel - > rd node . db Node , rel - > rd node . rel Node , map Block ) ) ) ; Lock Buffer ( map Buffer , BUFFER LOCK EXCLUSIVE ) ; map = ( unsigned char * ) Page Get Contents ( Buffer Get Page ( map Buffer ) ) ; rc = memset s ( map , BCMMAPSIZE , 0 , BCMMAPSIZE ) ; securec check ( rc , \" \" , \" \" ) ; Mark Buffer Dirty ( map Buffer ) ; Unlock Release Buffer ( map Buffer ) ; } }", "predictions": ["this method"], "references": ["clear all the bcm bits of the relationship"], "bleu": 0.031811104014284386, "rouge_l": 0.0}
